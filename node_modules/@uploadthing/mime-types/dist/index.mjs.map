{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Vendored version of mime-types that can run on the edge due to not using path.extname\n *\n * Also ported it to TypeScript cause it was easier than playing around with custom d.ts file\n *\n * Removed all the stuff we didn't use\n */\n\n/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n * @private\n */\nimport { mimeTypes as mimeDB } from \"./db\";\nimport type { FileExtension, MimeType } from \"./db\";\n\nfunction extname(path: string) {\n  const index = path.lastIndexOf(\".\");\n  return index < 0 ? \"\" : path.substring(index);\n}\n\nexport const extensions = {} as Record<MimeType, FileExtension[]>;\nexport const types = {} as Record<FileExtension, MimeType>;\n\n// Populate the extensions/types maps\npopulateMaps(extensions, types);\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\nexport function lookup(path: string) {\n  if (!path || typeof path !== \"string\") {\n    return false;\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  const extension = extname(\"x.\" + path)\n    .toLowerCase()\n    .substring(1) as FileExtension;\n\n  if (!extension) {\n    return false;\n  }\n\n  return types[extension] || false;\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps(\n  extensions: Record<MimeType, FileExtension[]>,\n  types: Record<FileExtension, MimeType>,\n) {\n  // source preference (least -> most)\n  const preference = [\"nginx\", \"apache\", undefined, \"iana\"];\n\n  (Object.keys(mimeDB) as MimeType[]).forEach((type) => {\n    const mime = mimeDB[type];\n    const exts = mime.extensions;\n\n    if (!exts?.length) {\n      return;\n    }\n\n    // mime -> extensions\n    extensions[type] = exts;\n\n    // extension -> mime\n\n    for (const extension of exts) {\n      if (types[extension]) {\n        const from = preference.indexOf(mimeDB[types[extension]].source);\n        const to = preference.indexOf(mime.source);\n\n        if (\n          types[extension] !== \"application/octet-stream\" &&\n          (from > to ||\n            (from === to && types[extension].startsWith(\"application/\")))\n        ) {\n          // skip the remapping\n          continue;\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type;\n    }\n  });\n}\n"],"mappings":";;;;;AAsBA,SAAS,QAAQ,MAAc;AAC7B,QAAM,QAAQ,KAAK,YAAY,GAAG;AAClC,SAAO,QAAQ,IAAI,KAAK,KAAK,UAAU,KAAK;AAC9C;AAEO,IAAM,aAAa,CAAC;AACpB,IAAM,QAAQ,CAAC;AAGtB,aAAa,YAAY,KAAK;AAQvB,SAAS,OAAO,MAAc;AACnC,MAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;AACrC,WAAO;AAAA,EACT;AAGA,QAAM,YAAY,QAAQ,OAAO,IAAI,EAClC,YAAY,EACZ,UAAU,CAAC;AAEd,MAAI,CAAC,WAAW;AACd,WAAO;AAAA,EACT;AAEA,SAAO,MAAM,SAAS,KAAK;AAC7B;AAOA,SAAS,aACPA,aACAC,QACA;AAEA,QAAM,aAAa,CAAC,SAAS,UAAU,QAAW,MAAM;AAExD,EAAC,OAAO,KAAK,SAAM,EAAiB,QAAQ,CAAC,SAAS;AACpD,UAAM,OAAO,UAAO,IAAI;AACxB,UAAM,OAAO,KAAK;AAElB,QAAI,EAAC,6BAAM,SAAQ;AACjB;AAAA,IACF;AAGA,IAAAD,YAAW,IAAI,IAAI;AAInB,eAAW,aAAa,MAAM;AAC5B,UAAIC,OAAM,SAAS,GAAG;AACpB,cAAM,OAAO,WAAW,QAAQ,UAAOA,OAAM,SAAS,CAAC,EAAE,MAAM;AAC/D,cAAM,KAAK,WAAW,QAAQ,KAAK,MAAM;AAEzC,YACEA,OAAM,SAAS,MAAM,+BACpB,OAAO,MACL,SAAS,MAAMA,OAAM,SAAS,EAAE,WAAW,cAAc,IAC5D;AAEA;AAAA,QACF;AAAA,MACF;AAGA,MAAAA,OAAM,SAAS,IAAI;AAAA,IACrB;AAAA,EACF,CAAC;AACH;","names":["extensions","types"]}