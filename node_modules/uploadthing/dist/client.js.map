{"version":3,"sources":["../src/client.ts","../src/internal/multi-part.ts","../src/internal/s3-error-parser.ts","../src/internal/ut-reporter.ts","../src/internal/component-theming.ts"],"sourcesContent":["import { safeParseJSON, UploadThingError } from \"@uploadthing/shared\";\n\nimport type { UploadThingResponse } from \"./internal/handler\";\nimport { uploadPartWithProgress } from \"./internal/multi-part\";\nimport type {\n  DistributiveOmit,\n  FileRouter,\n  inferEndpointInput,\n  inferEndpointOutput,\n} from \"./internal/types\";\nimport { createAPIRequestUrl, createUTReporter } from \"./internal/ut-reporter\";\n\n/**\n * @internal\n * Shared helpers for our premade components that's reusable by multiple frameworks\n */\nexport * from \"./internal/component-theming\";\n\ntype UploadFilesOptions<\n  TRouter extends FileRouter,\n  TEndpoint extends keyof TRouter,\n> = {\n  onUploadProgress?: ({\n    file,\n    progress,\n  }: {\n    file: string;\n    progress: number;\n  }) => void;\n  onUploadBegin?: ({ file }: { file: string }) => void;\n\n  files: File[];\n\n  /**\n   * URL to the UploadThing API endpoint\n   * @example URL { http://localhost:3000/api/uploadthing }\n   * @example URL { https://www.example.com/api/uploadthing }\n   */\n  url: URL;\n} & (undefined extends inferEndpointInput<TRouter[TEndpoint]>\n  ? // eslint-disable-next-line @typescript-eslint/ban-types\n    {}\n  : {\n      input: inferEndpointInput<TRouter[TEndpoint]>;\n    });\n\nexport const INTERNAL_DO_NOT_USE__fatalClientError = (e: Error) =>\n  new UploadThingError({\n    code: \"INTERNAL_CLIENT_ERROR\",\n    message: \"Something went wrong. Please report this to UploadThing.\",\n    cause: e,\n  });\n\nexport type UploadFileResponse<TServerOutput> = {\n  name: string;\n  size: number;\n  key: string;\n  url: string;\n  // Matches what's returned from the serverside `onUploadComplete` callback\n  serverData: TServerOutput;\n};\n\nexport const DANGEROUS__uploadFiles = async <\n  TRouter extends FileRouter,\n  TEndpoint extends keyof TRouter,\n>(\n  endpoint: TEndpoint,\n  opts: UploadFilesOptions<TRouter, TEndpoint>,\n) => {\n  const reportEventToUT = createUTReporter({\n    endpoint: String(endpoint),\n    url: opts.url,\n  });\n\n  // Get presigned URL for S3 upload\n  const s3ConnectionRes = await fetch(\n    createAPIRequestUrl({\n      url: opts.url,\n      slug: String(endpoint),\n      actionType: \"upload\",\n    }),\n    {\n      method: \"POST\",\n      body: JSON.stringify({\n        input: \"input\" in opts ? opts.input : null,\n        files: opts.files.map((f) => ({ name: f.name, size: f.size })),\n      }),\n      // Express requires Content-Type to be explicitly set to parse body properly\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    },\n  ).then(async (res) => {\n    // check for 200 response\n    if (!res.ok) {\n      const error = await UploadThingError.fromResponse(res);\n      throw error;\n    }\n\n    const jsonOrError = await safeParseJSON<UploadThingResponse>(res);\n    if (jsonOrError instanceof Error) {\n      throw new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: jsonOrError.message,\n        cause: res,\n      });\n    }\n    return jsonOrError;\n  });\n\n  if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes)) {\n    throw new UploadThingError({\n      code: \"BAD_REQUEST\",\n      message: \"No URL. How did you even get here?\",\n      cause: s3ConnectionRes,\n    });\n  }\n\n  const fileUploadPromises = s3ConnectionRes.map(async (presigned) => {\n    const file = opts.files.find((f) => f.name === presigned.fileName);\n\n    if (!file) {\n      console.error(\"No file found for presigned URL\", presigned);\n      throw new UploadThingError({\n        code: \"NOT_FOUND\",\n        message: \"No file found for presigned URL\",\n        cause: `Expected file with name ${\n          presigned.fileName\n        } but got '${opts.files.join(\",\")}'`,\n      });\n    }\n\n    const { presignedUrls, uploadId, chunkSize, contentDisposition, key } =\n      presigned;\n\n    let uploadedBytes = 0;\n\n    let etags: { tag: string; partNumber: number }[];\n    try {\n      etags = await Promise.all(\n        presignedUrls.map(async (url, index) => {\n          const offset = chunkSize * index;\n          const end = Math.min(offset + chunkSize, file.size);\n          const chunk = file.slice(offset, end);\n\n          const etag = await uploadPartWithProgress({\n            url,\n            chunk: chunk,\n            contentDisposition,\n            fileType: file.type,\n            fileName: file.name,\n            maxRetries: 10,\n            onProgress: (delta) => {\n              uploadedBytes += delta;\n              const percent = (uploadedBytes / file.size) * 100;\n              opts.onUploadProgress?.({ file: file.name, progress: percent });\n            },\n          });\n\n          return { tag: etag, partNumber: index + 1 };\n        }),\n      );\n    } catch (error) {\n      await reportEventToUT(\"failure\", {\n        fileKey: key,\n        uploadId,\n        fileName: file.name,\n        s3Error: (error as Error).toString(),\n      });\n      throw \"unreachable\"; // failure event will throw for us\n    }\n\n    // Tell the server that the upload is complete\n    const uploadOk = await reportEventToUT(\"multipart-complete\", {\n      uploadId,\n      fileKey: key,\n      etags,\n    });\n    if (!uploadOk) {\n      console.log(\"Failed to alert UT of upload completion\");\n      throw new UploadThingError({\n        code: \"UPLOAD_FAILED\",\n        message: \"Failed to alert UT of upload completion\",\n      });\n    }\n\n    const serverData = await fetch(opts.url, {\n      headers: { \"x-uploadthing-polling-key\": key },\n    }).then(\n      (res) => res.json() as Promise<inferEndpointOutput<TRouter[TEndpoint]>>,\n    );\n\n    return {\n      name: file.name,\n      size: file.size,\n      key: presigned.key,\n\n      serverData,\n      url: \"https://utfs.io/f/\" + key,\n    } satisfies UploadFileResponse<inferEndpointOutput<TRouter[TEndpoint]>>;\n  });\n\n  return Promise.all(fileUploadPromises);\n};\n\nexport const genUploader = <TRouter extends FileRouter>(initOpts: {\n  /**\n   * URL to the UploadThing API endpoint\n   * @example URL { /api/uploadthing }\n   * @example URL { https://www.example.com/api/uploadthing }\n   *\n   * If relative, host will be inferred from either the `VERCEL_URL` environment variable or `window.location.origin`\n   *\n   * @default (VERCEL_URL ?? window.location.origin) + \"/api/uploadthing\"\n   */\n  url?: string | URL;\n}) => {\n  const url =\n    initOpts?.url instanceof URL ? initOpts.url : getFullApiUrl(initOpts?.url);\n\n  return <TEndpoint extends keyof TRouter>(\n    endpoint: TEndpoint,\n    opts: DistributiveOmit<\n      Parameters<typeof DANGEROUS__uploadFiles<TRouter, TEndpoint>>[1],\n      \"url\"\n    >,\n  ) =>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    DANGEROUS__uploadFiles<TRouter, TEndpoint>(endpoint, {\n      ...opts,\n      url,\n    } as any);\n};\n\nexport const classNames = (...classes: (string | boolean)[]) => {\n  return classes.filter(Boolean).join(\" \");\n};\n\nexport const generateMimeTypes = (fileTypes: string[]) => {\n  const accepted = fileTypes.map((type) => {\n    if (type === \"blob\") return \"blob\";\n    if (type === \"pdf\") return \"application/pdf\";\n    if (type.includes(\"/\")) return type;\n    else return `${type}/*`;\n  });\n\n  if (accepted.includes(\"blob\")) {\n    return undefined;\n  }\n  return accepted;\n};\n\nexport const generateClientDropzoneAccept = (fileTypes: string[]) => {\n  const mimeTypes = generateMimeTypes(fileTypes);\n\n  if (!mimeTypes) return undefined;\n\n  return Object.fromEntries(mimeTypes.map((type) => [type, []]));\n};\n\n// Returns a full URL to the dev's uploadthing endpoint\nexport function getFullApiUrl(maybeUrl?: string): URL {\n  const base = (() => {\n    if (typeof window !== \"undefined\") {\n      return window.location.origin;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof process !== \"undefined\" && process?.env?.VERCEL_URL) {\n      return `https://${process.env.VERCEL_URL}`;\n    }\n\n    // @ts-expect-error - import meta is not defined in node\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (import.meta.env?.VERCEL_URL) {\n      // @ts-expect-error - import meta is not defined in node\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return `https://${import.meta.env.VERCEL_URL}`;\n    }\n\n    return \"http://localhost:3000\";\n  })();\n\n  try {\n    const url = new URL(maybeUrl ?? \"/api/uploadthing\", base);\n    if (url.pathname === \"/\") {\n      url.pathname = \"/api/uploadthing\";\n    }\n    return url;\n  } catch (err) {\n    throw new Error(\n      `Failed to parse '${maybeUrl}' as a URL. Make sure it's a valid URL or path`,\n    );\n  }\n}\n","import { generateUploadThingURL, UploadThingError } from \"@uploadthing/shared\";\nimport type { ContentDisposition, FetchEsque } from \"@uploadthing/shared\";\n\nimport { maybeParseResponseXML } from \"./s3-error-parser\";\n\n/**\n * Used by server uploads where progress is not needed.\n * Uses normal fetch API.\n */\nexport async function uploadPart(\n  opts: {\n    fetch: FetchEsque;\n    url: string;\n    key: string;\n    chunk: Blob;\n    contentType: string;\n    contentDisposition: ContentDisposition;\n    fileName: string;\n    maxRetries: number;\n    utRequestHeaders: Record<string, string>;\n  },\n  retryCount = 0,\n) {\n  const s3Res = await opts.fetch(opts.url, {\n    method: \"PUT\",\n    body: opts.chunk,\n    headers: {\n      \"Content-Type\": opts.contentType,\n      \"Content-Disposition\": [\n        opts.contentDisposition,\n        `filename=\"${opts.fileName}\"`,\n        `filename*=UTF-8''${opts.fileName}`,\n      ].join(\"; \"),\n    },\n  });\n\n  if (s3Res.ok) {\n    const etag = s3Res.headers.get(\"Etag\");\n    if (!etag) {\n      throw new UploadThingError({\n        code: \"UPLOAD_FAILED\",\n        message: \"Missing Etag header from uploaded part\",\n      });\n    }\n    return etag.replace(/\"/g, \"\");\n  }\n\n  if (retryCount < opts.maxRetries) {\n    // Retry after exponential backoff\n    const delay = 2 ** retryCount * 1000;\n    await new Promise((r) => setTimeout(r, delay));\n    return uploadPart(opts, retryCount++);\n  }\n\n  // Max retries exceeded, tell UT server that upload failed\n  await opts.fetch(generateUploadThingURL(\"/api/failureCallback\"), {\n    method: \"POST\",\n    body: JSON.stringify({\n      fileKey: opts.key,\n    }),\n    headers: opts.utRequestHeaders,\n  });\n\n  const text = await s3Res.text();\n  const parsed = maybeParseResponseXML(text);\n  if (parsed?.message) {\n    throw new UploadThingError({\n      code: \"UPLOAD_FAILED\",\n      message: parsed.message,\n    });\n  }\n  throw new UploadThingError({\n    code: \"UPLOAD_FAILED\",\n    message: \"Failed to upload file to storage provider\",\n    cause: s3Res,\n  });\n}\n\n/**\n * Used by client uploads where progress is needed.\n * Uses XMLHttpRequest.\n */\nexport async function uploadPartWithProgress(\n  opts: {\n    url: string;\n    chunk: Blob;\n    fileType: string;\n    fileName: string;\n    contentDisposition: ContentDisposition;\n    maxRetries: number;\n    onProgress: (progressDelta: number) => void;\n  },\n  retryCount = 0,\n) {\n  return new Promise<string>((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n\n    xhr.open(\"PUT\", opts.url, true);\n    xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n    xhr.setRequestHeader(\n      \"Content-Disposition\",\n      [\n        opts.contentDisposition,\n        `filename=\"${opts.fileName}\"`,\n        `filename*=UTF-8''${opts.fileName}`,\n      ].join(\"; \"),\n    );\n\n    xhr.onload = async () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        const etag = xhr.getResponseHeader(\"Etag\");\n        etag ? resolve(etag) : reject(\"NO ETAG\");\n      } else if (retryCount < opts.maxRetries) {\n        // Add a delay before retrying (exponential backoff can be used)\n        const delay = Math.pow(2, retryCount) * 1000;\n        await new Promise((res) => setTimeout(res, delay));\n        await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n      } else {\n        reject(\"Max retries exceeded\");\n      }\n    };\n\n    let lastProgress = 0;\n\n    xhr.onerror = async () => {\n      lastProgress = 0;\n      if (retryCount < opts.maxRetries) {\n        // Add a delay before retrying (exponential backoff can be used)\n        const delay = Math.pow(2, retryCount) * 100;\n        await new Promise((res) => setTimeout(res, delay));\n        await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n      } else {\n        reject(\"Max retries exceeded\");\n      }\n    };\n\n    xhr.upload.onprogress = (e) => {\n      const delta = e.loaded - lastProgress;\n      lastProgress += delta;\n      opts.onProgress(delta);\n    };\n\n    xhr.send(opts.chunk);\n  });\n}\n","import type { UploadThingError } from \"@uploadthing/shared\";\n\nexport const maybeParseResponseXML = (maybeXml: string) => {\n  const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n  const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n\n  const code = codeMatch?.[1];\n  const message = messageMatch?.[1];\n\n  if (!code || !message) return null;\n\n  return { code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE, message };\n};\n\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */\nconst DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode: Record<string, UploadThingError[\"code\"]> = {\n  AccessDenied: \"FORBIDDEN\", // 403 Forbidden\n  EntityTooSmall: \"TOO_SMALL\", // 400 Bad Request\n  EntityTooLarge: \"TOO_LARGE\", // 400 Bad Request\n  ExpiredToken: \"FORBIDDEN\", // 400 Bad Request\n  IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\", // 400 Bad Request\n  InternalError: \"INTERNAL_SERVER_ERROR\", // 500 Internal Server Error\n  KeyTooLongError: \"KEY_TOO_LONG\", // 400 Bad Request\n  MaxMessageLengthExceeded: \"TOO_LARGE\", // 400 Bad Request\n};\n","import { UploadThingError } from \"@uploadthing/shared\";\n\nimport { maybeParseResponseXML } from \"./s3-error-parser\";\nimport type { ActionType, UTEvents } from \"./types\";\n\nexport const createAPIRequestUrl = (config: {\n  /**\n   * URL to the UploadThing API endpoint\n   * @example URL { /api/uploadthing }\n   * @example URL { https://www.example.com/api/uploadthing }\n   */\n  url: URL;\n  slug: string;\n  actionType: ActionType;\n}) => {\n  const url = new URL(config.url);\n\n  const queryParams = new URLSearchParams(url.search);\n  queryParams.set(\"actionType\", config.actionType);\n  queryParams.set(\"slug\", config.slug);\n\n  url.search = queryParams.toString();\n  return url;\n};\n\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L200\"\n */\nexport const createUTReporter = (cfg: { url: URL; endpoint: string }) => {\n  return async <TEvent extends keyof UTEvents>(\n    type: TEvent,\n    payload: UTEvents[TEvent],\n  ) => {\n    const url = createAPIRequestUrl({\n      url: cfg.url,\n      slug: cfg.endpoint,\n      actionType: type,\n    });\n    const response = await fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(payload),\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n\n    switch (type) {\n      case \"failure\": {\n        // why isn't this narrowed automatically?\n        const p = payload as UTEvents[\"failure\"];\n        const parsed = maybeParseResponseXML(p.s3Error ?? \"\");\n        if (parsed?.message) {\n          throw new UploadThingError({\n            code: parsed.code,\n            message: parsed.message,\n          });\n        } else {\n          throw new UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: `Failed to upload file ${p.fileName} to S3`,\n            cause: p.s3Error,\n          });\n        }\n      }\n    }\n\n    return response.ok;\n  };\n};\n","import type { CSSProperties, ReactNode } from \"react\";\nimport type { JSX } from \"solid-js/jsx-runtime\";\n\nimport { objectKeys } from \"@uploadthing/shared\";\nimport type { ExpandedRouteConfig } from \"@uploadthing/shared\";\n\n/**\n * Shared helpers for our premade components that's reusable by multiple frameworks\n */\n\nexport const generatePermittedFileTypes = (config?: ExpandedRouteConfig) => {\n  const fileTypes = config ? objectKeys(config) : [];\n\n  const maxFileCount = config\n    ? Object.values(config).map((v) => v.maxFileCount)\n    : [];\n\n  return { fileTypes, multiple: maxFileCount.some((v) => v && v > 1) };\n};\n\nexport const capitalizeStart = (str: string) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexport const INTERNAL_doFormatting = (config?: ExpandedRouteConfig): string => {\n  if (!config) return \"\";\n\n  const allowedTypes = objectKeys(config);\n\n  const formattedTypes = allowedTypes.map((f) => (f === \"blob\" ? \"file\" : f));\n\n  // Format multi-type uploader label as \"Supports videos, images and files\";\n  if (formattedTypes.length > 1) {\n    const lastType = formattedTypes.pop();\n    return `${formattedTypes.join(\"s, \")} and ${lastType}s`;\n  }\n\n  // Single type uploader label\n  const key = allowedTypes[0];\n  const formattedKey = formattedTypes[0];\n\n  const { maxFileSize, maxFileCount } = config[key]!;\n\n  if (maxFileCount && maxFileCount > 1) {\n    return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;\n  } else {\n    return `${formattedKey} (${maxFileSize})`;\n  }\n};\n\nexport const allowedContentTextLabelGenerator = (\n  config?: ExpandedRouteConfig,\n): string => {\n  return capitalizeStart(INTERNAL_doFormatting(config));\n};\n\ntype AnyRuntime = \"react\" | \"solid\";\ntype MinCallbackArg = { __runtime: AnyRuntime };\ntype inferRuntime<T extends MinCallbackArg> = T[\"__runtime\"] extends \"react\"\n  ? \"react\"\n  : \"solid\";\n\ntype ElementEsque<TRuntime extends AnyRuntime> = TRuntime extends \"react\"\n  ? ReactNode\n  : JSX.Element;\ntype CSSPropertiesEsque<TRuntime extends AnyRuntime> = TRuntime extends \"react\"\n  ? CSSProperties\n  : JSX.CSSProperties;\n\nexport type StyleField<\n  CallbackArg extends MinCallbackArg,\n  TRuntime extends AnyRuntime = inferRuntime<CallbackArg>,\n> =\n  | string\n  | CSSPropertiesEsque<TRuntime>\n  | ((\n      arg: Omit<CallbackArg, \"__runtime\">,\n    ) => string | CSSPropertiesEsque<TRuntime>);\n\nexport type ContentField<\n  CallbackArg extends MinCallbackArg,\n  TRuntime extends AnyRuntime = inferRuntime<CallbackArg>,\n> =\n  | ElementEsque<TRuntime>\n  | ((arg: Omit<CallbackArg, \"__runtime\">) => ElementEsque<TRuntime>);\n\nexport const styleFieldToClassName = <T extends MinCallbackArg>(\n  styleField: StyleField<T> | undefined,\n  args: T,\n) => {\n  if (typeof styleField === \"string\") return styleField;\n  if (typeof styleField === \"function\") {\n    const result = styleField(args);\n\n    if (typeof result === \"string\") return result;\n  }\n\n  return \"\";\n};\n\nexport const styleFieldToCssObject = <T extends MinCallbackArg>(\n  styleField: StyleField<T> | undefined,\n  args: T,\n) => {\n  if (typeof styleField === \"object\") return styleField;\n  if (typeof styleField === \"function\") {\n    const result = styleField(args);\n\n    if (typeof result === \"object\") return result;\n  }\n\n  return {};\n};\n\nexport const contentFieldToContent = <T extends MinCallbackArg>(\n  contentField: ContentField<T> | undefined,\n  arg: T,\n) => {\n  if (!contentField) return null;\n  if (typeof contentField !== \"function\") return contentField;\n  if (typeof contentField === \"function\") {\n    const result = contentField(arg);\n\n    return result;\n  }\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,iBAAgD;;;ACAhD,oBAAyD;;;ACElD,IAAM,wBAAwB,CAAC,aAAqB;AACzD,QAAM,YAAY,SAAS,MAAM,sBAAsB;AACvD,QAAM,eAAe,SAAS,MAAM,4BAA4B;AAEhE,QAAM,OAAO,uCAAY;AACzB,QAAM,UAAU,6CAAe;AAE/B,MAAI,CAAC,QAAQ,CAAC;AAAS,WAAO;AAE9B,SAAO,EAAE,MAAM,wBAAwB,IAAI,KAAK,oBAAoB,QAAQ;AAC9E;AASA,IAAM,qBAAqB;AAC3B,IAAM,0BAAoE;AAAA,EACxE,cAAc;AAAA;AAAA,EACd,gBAAgB;AAAA;AAAA,EAChB,gBAAgB;AAAA;AAAA,EAChB,cAAc;AAAA;AAAA,EACd,qCAAqC;AAAA;AAAA,EACrC,eAAe;AAAA;AAAA,EACf,iBAAiB;AAAA;AAAA,EACjB,0BAA0B;AAAA;AAC5B;;;ADmDA,eAAsB,uBACpB,MASA,aAAa,GACb;AACA,SAAO,IAAI,QAAgB,CAAC,SAAS,WAAW;AAC9C,UAAM,MAAM,IAAI,eAAe;AAE/B,QAAI,KAAK,OAAO,KAAK,KAAK,IAAI;AAC9B,QAAI,iBAAiB,gBAAgB,KAAK,QAAQ;AAClD,QAAI;AAAA,MACF;AAAA,MACA;AAAA,QACE,KAAK;AAAA,QACL,aAAa,KAAK;AAAA,QAClB,oBAAoB,KAAK;AAAA,MAC3B,EAAE,KAAK,IAAI;AAAA,IACb;AAEA,QAAI,SAAS,YAAY;AACvB,UAAI,IAAI,UAAU,OAAO,IAAI,SAAS,KAAK;AACzC,cAAM,OAAO,IAAI,kBAAkB,MAAM;AACzC,eAAO,QAAQ,IAAI,IAAI,OAAO,SAAS;AAAA,MACzC,WAAW,aAAa,KAAK,YAAY;AAEvC,cAAM,QAAQ,KAAK,IAAI,GAAG,UAAU,IAAI;AACxC,cAAM,IAAI,QAAQ,CAAC,QAAQ,WAAW,KAAK,KAAK,CAAC;AACjD,cAAM,uBAAuB,MAAM,aAAa,CAAC;AAAA,MACnD,OAAO;AACL,eAAO,sBAAsB;AAAA,MAC/B;AAAA,IACF;AAEA,QAAI,eAAe;AAEnB,QAAI,UAAU,YAAY;AACxB,qBAAe;AACf,UAAI,aAAa,KAAK,YAAY;AAEhC,cAAM,QAAQ,KAAK,IAAI,GAAG,UAAU,IAAI;AACxC,cAAM,IAAI,QAAQ,CAAC,QAAQ,WAAW,KAAK,KAAK,CAAC;AACjD,cAAM,uBAAuB,MAAM,aAAa,CAAC;AAAA,MACnD,OAAO;AACL,eAAO,sBAAsB;AAAA,MAC/B;AAAA,IACF;AAEA,QAAI,OAAO,aAAa,CAAC,MAAM;AAC7B,YAAM,QAAQ,EAAE,SAAS;AACzB,sBAAgB;AAChB,WAAK,WAAW,KAAK;AAAA,IACvB;AAEA,QAAI,KAAK,KAAK,KAAK;AAAA,EACrB,CAAC;AACH;;;AEhJA,IAAAC,iBAAiC;AAK1B,IAAM,sBAAsB,CAAC,WAS9B;AACJ,QAAM,MAAM,IAAI,IAAI,OAAO,GAAG;AAE9B,QAAM,cAAc,IAAI,gBAAgB,IAAI,MAAM;AAClD,cAAY,IAAI,cAAc,OAAO,UAAU;AAC/C,cAAY,IAAI,QAAQ,OAAO,IAAI;AAEnC,MAAI,SAAS,YAAY,SAAS;AAClC,SAAO;AACT;AAMO,IAAM,mBAAmB,CAAC,QAAwC;AACvE,SAAO,OACL,MACA,YACG;AACH,UAAM,MAAM,oBAAoB;AAAA,MAC9B,KAAK,IAAI;AAAA,MACT,MAAM,IAAI;AAAA,MACV,YAAY;AAAA,IACd,CAAC;AACD,UAAM,WAAW,MAAM,MAAM,KAAK;AAAA,MAChC,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,OAAO;AAAA,MAC5B,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,IAChD,CAAC;AAED,YAAQ,MAAM;AAAA,MACZ,KAAK,WAAW;AAEd,cAAM,IAAI;AACV,cAAM,SAAS,sBAAsB,EAAE,WAAW,EAAE;AACpD,YAAI,iCAAQ,SAAS;AACnB,gBAAM,IAAI,gCAAiB;AAAA,YACzB,MAAM,OAAO;AAAA,YACb,SAAS,OAAO;AAAA,UAClB,CAAC;AAAA,QACH,OAAO;AACL,gBAAM,IAAI,gCAAiB;AAAA,YACzB,MAAM;AAAA,YACN,SAAS,yBAAyB,EAAE;AAAA,YACpC,OAAO,EAAE;AAAA,UACX,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAEA,WAAO,SAAS;AAAA,EAClB;AACF;;;AChEA,IAAAC,iBAA2B;AAOpB,IAAM,6BAA6B,CAAC,WAAiC;AAC1E,QAAM,YAAY,aAAS,2BAAW,MAAM,IAAI,CAAC;AAEjD,QAAM,eAAe,SACjB,OAAO,OAAO,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,YAAY,IAC/C,CAAC;AAEL,SAAO,EAAE,WAAW,UAAU,aAAa,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,EAAE;AACrE;AAEO,IAAM,kBAAkB,CAAC,QAAgB;AAC9C,SAAO,IAAI,OAAO,CAAC,EAAE,YAAY,IAAI,IAAI,MAAM,CAAC;AAClD;AAEO,IAAM,wBAAwB,CAAC,WAAyC;AAC7E,MAAI,CAAC;AAAQ,WAAO;AAEpB,QAAM,mBAAe,2BAAW,MAAM;AAEtC,QAAM,iBAAiB,aAAa,IAAI,CAAC,MAAO,MAAM,SAAS,SAAS,CAAE;AAG1E,MAAI,eAAe,SAAS,GAAG;AAC7B,UAAM,WAAW,eAAe,IAAI;AACpC,WAAO,GAAG,eAAe,KAAK,KAAK,SAAS;AAAA,EAC9C;AAGA,QAAM,MAAM,aAAa,CAAC;AAC1B,QAAM,eAAe,eAAe,CAAC;AAErC,QAAM,EAAE,aAAa,aAAa,IAAI,OAAO,GAAG;AAEhD,MAAI,gBAAgB,eAAe,GAAG;AACpC,WAAO,GAAG,uBAAuB,oBAAoB;AAAA,EACvD,OAAO;AACL,WAAO,GAAG,iBAAiB;AAAA,EAC7B;AACF;AAEO,IAAM,mCAAmC,CAC9C,WACW;AACX,SAAO,gBAAgB,sBAAsB,MAAM,CAAC;AACtD;AAgCO,IAAM,wBAAwB,CACnC,YACA,SACG;AACH,MAAI,OAAO,eAAe;AAAU,WAAO;AAC3C,MAAI,OAAO,eAAe,YAAY;AACpC,UAAM,SAAS,WAAW,IAAI;AAE9B,QAAI,OAAO,WAAW;AAAU,aAAO;AAAA,EACzC;AAEA,SAAO;AACT;AAEO,IAAM,wBAAwB,CACnC,YACA,SACG;AACH,MAAI,OAAO,eAAe;AAAU,WAAO;AAC3C,MAAI,OAAO,eAAe,YAAY;AACpC,UAAM,SAAS,WAAW,IAAI;AAE9B,QAAI,OAAO,WAAW;AAAU,aAAO;AAAA,EACzC;AAEA,SAAO,CAAC;AACV;AAEO,IAAM,wBAAwB,CACnC,cACA,QACG;AACH,MAAI,CAAC;AAAc,WAAO;AAC1B,MAAI,OAAO,iBAAiB;AAAY,WAAO;AAC/C,MAAI,OAAO,iBAAiB,YAAY;AACtC,UAAM,SAAS,aAAa,GAAG;AAE/B,WAAO;AAAA,EACT;AACF;;;AJ7HA;AA8CO,IAAM,wCAAwC,CAAC,MACpD,IAAI,gCAAiB;AAAA,EACnB,MAAM;AAAA,EACN,SAAS;AAAA,EACT,OAAO;AACT,CAAC;AAWI,IAAM,yBAAyB,OAIpC,UACA,SACG;AACH,QAAM,kBAAkB,iBAAiB;AAAA,IACvC,UAAU,OAAO,QAAQ;AAAA,IACzB,KAAK,KAAK;AAAA,EACZ,CAAC;AAGD,QAAM,kBAAkB,MAAM;AAAA,IAC5B,oBAAoB;AAAA,MAClB,KAAK,KAAK;AAAA,MACV,MAAM,OAAO,QAAQ;AAAA,MACrB,YAAY;AAAA,IACd,CAAC;AAAA,IACD;AAAA,MACE,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU;AAAA,QACnB,OAAO,WAAW,OAAO,KAAK,QAAQ;AAAA,QACtC,OAAO,KAAK,MAAM,IAAI,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,MAAM,EAAE,KAAK,EAAE;AAAA,MAC/D,CAAC;AAAA;AAAA,MAED,SAAS;AAAA,QACP,gBAAgB;AAAA,MAClB;AAAA,IACF;AAAA,EACF,EAAE,KAAK,OAAO,QAAQ;AAEpB,QAAI,CAAC,IAAI,IAAI;AACX,YAAM,QAAQ,MAAM,gCAAiB,aAAa,GAAG;AACrD,YAAM;AAAA,IACR;AAEA,UAAM,cAAc,UAAM,8BAAmC,GAAG;AAChE,QAAI,uBAAuB,OAAO;AAChC,YAAM,IAAI,gCAAiB;AAAA,QACzB,MAAM;AAAA,QACN,SAAS,YAAY;AAAA,QACrB,OAAO;AAAA,MACT,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT,CAAC;AAED,MAAI,CAAC,mBAAmB,CAAC,MAAM,QAAQ,eAAe,GAAG;AACvD,UAAM,IAAI,gCAAiB;AAAA,MACzB,MAAM;AAAA,MACN,SAAS;AAAA,MACT,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AAEA,QAAM,qBAAqB,gBAAgB,IAAI,OAAO,cAAc;AAClE,UAAM,OAAO,KAAK,MAAM,KAAK,CAAC,MAAM,EAAE,SAAS,UAAU,QAAQ;AAEjE,QAAI,CAAC,MAAM;AACT,cAAQ,MAAM,mCAAmC,SAAS;AAC1D,YAAM,IAAI,gCAAiB;AAAA,QACzB,MAAM;AAAA,QACN,SAAS;AAAA,QACT,OAAO,2BACL,UAAU,qBACC,KAAK,MAAM,KAAK,GAAG;AAAA,MAClC,CAAC;AAAA,IACH;AAEA,UAAM,EAAE,eAAe,UAAU,WAAW,oBAAoB,IAAI,IAClE;AAEF,QAAI,gBAAgB;AAEpB,QAAI;AACJ,QAAI;AACF,cAAQ,MAAM,QAAQ;AAAA,QACpB,cAAc,IAAI,OAAO,KAAK,UAAU;AACtC,gBAAM,SAAS,YAAY;AAC3B,gBAAM,MAAM,KAAK,IAAI,SAAS,WAAW,KAAK,IAAI;AAClD,gBAAM,QAAQ,KAAK,MAAM,QAAQ,GAAG;AAEpC,gBAAM,OAAO,MAAM,uBAAuB;AAAA,YACxC;AAAA,YACA;AAAA,YACA;AAAA,YACA,UAAU,KAAK;AAAA,YACf,UAAU,KAAK;AAAA,YACf,YAAY;AAAA,YACZ,YAAY,CAAC,UAAU;AAxJnC;AAyJc,+BAAiB;AACjB,oBAAM,UAAW,gBAAgB,KAAK,OAAQ;AAC9C,yBAAK,qBAAL,8BAAwB,EAAE,MAAM,KAAK,MAAM,UAAU,QAAQ;AAAA,YAC/D;AAAA,UACF,CAAC;AAED,iBAAO,EAAE,KAAK,MAAM,YAAY,QAAQ,EAAE;AAAA,QAC5C,CAAC;AAAA,MACH;AAAA,IACF,SAAS,OAAP;AACA,YAAM,gBAAgB,WAAW;AAAA,QAC/B,SAAS;AAAA,QACT;AAAA,QACA,UAAU,KAAK;AAAA,QACf,SAAU,MAAgB,SAAS;AAAA,MACrC,CAAC;AACD,YAAM;AAAA,IACR;AAGA,UAAM,WAAW,MAAM,gBAAgB,sBAAsB;AAAA,MAC3D;AAAA,MACA,SAAS;AAAA,MACT;AAAA,IACF,CAAC;AACD,QAAI,CAAC,UAAU;AACb,cAAQ,IAAI,yCAAyC;AACrD,YAAM,IAAI,gCAAiB;AAAA,QACzB,MAAM;AAAA,QACN,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAEA,UAAM,aAAa,MAAM,MAAM,KAAK,KAAK;AAAA,MACvC,SAAS,EAAE,6BAA6B,IAAI;AAAA,IAC9C,CAAC,EAAE;AAAA,MACD,CAAC,QAAQ,IAAI,KAAK;AAAA,IACpB;AAEA,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,MACX,KAAK,UAAU;AAAA,MAEf;AAAA,MACA,KAAK,uBAAuB;AAAA,IAC9B;AAAA,EACF,CAAC;AAED,SAAO,QAAQ,IAAI,kBAAkB;AACvC;AAEO,IAAM,cAAc,CAA6B,aAWlD;AACJ,QAAM,OACJ,qCAAU,gBAAe,MAAM,SAAS,MAAM,cAAc,qCAAU,GAAG;AAE3E,SAAO,CACL,UACA;AAAA;AAAA,IAMA,uBAA2C,UAAU;AAAA,MACnD,GAAG;AAAA,MACH;AAAA,IACF,CAAQ;AAAA;AACZ;AAEO,IAAM,aAAa,IAAI,YAAkC;AAC9D,SAAO,QAAQ,OAAO,OAAO,EAAE,KAAK,GAAG;AACzC;AAEO,IAAM,oBAAoB,CAAC,cAAwB;AACxD,QAAM,WAAW,UAAU,IAAI,CAAC,SAAS;AACvC,QAAI,SAAS;AAAQ,aAAO;AAC5B,QAAI,SAAS;AAAO,aAAO;AAC3B,QAAI,KAAK,SAAS,GAAG;AAAG,aAAO;AAAA;AAC1B,aAAO,GAAG;AAAA,EACjB,CAAC;AAED,MAAI,SAAS,SAAS,MAAM,GAAG;AAC7B,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,IAAM,+BAA+B,CAAC,cAAwB;AACnE,QAAM,YAAY,kBAAkB,SAAS;AAE7C,MAAI,CAAC;AAAW,WAAO;AAEvB,SAAO,OAAO,YAAY,UAAU,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAC/D;AAGO,SAAS,cAAc,UAAwB;AACpD,QAAM,QAAQ,MAAM;AAtQtB;AAuQI,QAAI,OAAO,WAAW,aAAa;AACjC,aAAO,OAAO,SAAS;AAAA,IACzB;AAGA,QAAI,OAAO,YAAY,iBAAe,wCAAS,QAAT,mBAAc,aAAY;AAC9D,aAAO,WAAW,QAAQ,IAAI;AAAA,IAChC;AAIA,SAAI,iBAAY,QAAZ,mBAAiB,YAAY;AAG/B,aAAO,WAAW,YAAY,IAAI;AAAA,IACpC;AAEA,WAAO;AAAA,EACT,GAAG;AAEH,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,YAAY,oBAAoB,IAAI;AACxD,QAAI,IAAI,aAAa,KAAK;AACxB,UAAI,WAAW;AAAA,IACjB;AACA,WAAO;AAAA,EACT,SAAS,KAAP;AACA,UAAM,IAAI;AAAA,MACR,oBAAoB;AAAA,IACtB;AAAA,EACF;AACF;","names":["import_shared","import_shared","import_shared"]}