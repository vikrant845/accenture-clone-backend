// src/internal/multi-part.ts
import { generateUploadThingURL, UploadThingError } from "@uploadthing/shared";

// src/internal/s3-error-parser.ts
var maybeParseResponseXML = (maybeXml) => {
  const codeMatch = maybeXml.match(/<Code>(.*?)<\/Code>/s);
  const messageMatch = maybeXml.match(/<Message>(.*?)<\/Message>/s);
  const code = codeMatch == null ? void 0 : codeMatch[1];
  const message = messageMatch == null ? void 0 : messageMatch[1];
  if (!code || !message)
    return null;
  return { code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE, message };
};
var DEFAULT_ERROR_CODE = "UPLOAD_FAILED";
var s3CodeToUploadThingCode = {
  AccessDenied: "FORBIDDEN",
  // 403 Forbidden
  EntityTooSmall: "TOO_SMALL",
  // 400 Bad Request
  EntityTooLarge: "TOO_LARGE",
  // 400 Bad Request
  ExpiredToken: "FORBIDDEN",
  // 400 Bad Request
  IncorrectNumberOfFilesInPostRequest: "TOO_MANY_FILES",
  // 400 Bad Request
  InternalError: "INTERNAL_SERVER_ERROR",
  // 500 Internal Server Error
  KeyTooLongError: "KEY_TOO_LONG",
  // 400 Bad Request
  MaxMessageLengthExceeded: "TOO_LARGE"
  // 400 Bad Request
};

// src/internal/multi-part.ts
async function uploadPart(opts, retryCount = 0) {
  const s3Res = await opts.fetch(opts.url, {
    method: "PUT",
    body: opts.chunk,
    headers: {
      "Content-Type": opts.contentType,
      "Content-Disposition": [
        opts.contentDisposition,
        `filename="${opts.fileName}"`,
        `filename*=UTF-8''${opts.fileName}`
      ].join("; ")
    }
  });
  if (s3Res.ok) {
    const etag = s3Res.headers.get("Etag");
    if (!etag) {
      throw new UploadThingError({
        code: "UPLOAD_FAILED",
        message: "Missing Etag header from uploaded part"
      });
    }
    return etag.replace(/"/g, "");
  }
  if (retryCount < opts.maxRetries) {
    const delay = 2 ** retryCount * 1e3;
    await new Promise((r) => setTimeout(r, delay));
    return uploadPart(opts, retryCount++);
  }
  await opts.fetch(generateUploadThingURL("/api/failureCallback"), {
    method: "POST",
    body: JSON.stringify({
      fileKey: opts.key
    }),
    headers: opts.utRequestHeaders
  });
  const text = await s3Res.text();
  const parsed = maybeParseResponseXML(text);
  if (parsed == null ? void 0 : parsed.message) {
    throw new UploadThingError({
      code: "UPLOAD_FAILED",
      message: parsed.message
    });
  }
  throw new UploadThingError({
    code: "UPLOAD_FAILED",
    message: "Failed to upload file to storage provider",
    cause: s3Res
  });
}
async function uploadPartWithProgress(opts, retryCount = 0) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("PUT", opts.url, true);
    xhr.setRequestHeader("Content-Type", opts.fileType);
    xhr.setRequestHeader(
      "Content-Disposition",
      [
        opts.contentDisposition,
        `filename="${opts.fileName}"`,
        `filename*=UTF-8''${opts.fileName}`
      ].join("; ")
    );
    xhr.onload = async () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        const etag = xhr.getResponseHeader("Etag");
        etag ? resolve(etag) : reject("NO ETAG");
      } else if (retryCount < opts.maxRetries) {
        const delay = Math.pow(2, retryCount) * 1e3;
        await new Promise((res) => setTimeout(res, delay));
        await uploadPartWithProgress(opts, retryCount + 1);
      } else {
        reject("Max retries exceeded");
      }
    };
    let lastProgress = 0;
    xhr.onerror = async () => {
      lastProgress = 0;
      if (retryCount < opts.maxRetries) {
        const delay = Math.pow(2, retryCount) * 100;
        await new Promise((res) => setTimeout(res, delay));
        await uploadPartWithProgress(opts, retryCount + 1);
      } else {
        reject("Max retries exceeded");
      }
    };
    xhr.upload.onprogress = (e) => {
      const delta = e.loaded - lastProgress;
      lastProgress += delta;
      opts.onProgress(delta);
    };
    xhr.send(opts.chunk);
  });
}

export {
  maybeParseResponseXML,
  uploadPart,
  uploadPartWithProgress
};
//# sourceMappingURL=chunk-J63ZFLAK.mjs.map