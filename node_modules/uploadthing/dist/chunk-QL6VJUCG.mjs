import {
  uploadPart
} from "./chunk-J63ZFLAK.mjs";
import {
  incompatibleNodeGuard
} from "./chunk-WPSY3MFJ.mjs";
import {
  UPLOADTHING_VERSION,
  buildPermissionsInfoHandler,
  buildRequestHandler,
  createBuilder,
  formatError
} from "./chunk-TYV4HEV2.mjs";

// src/server.ts
import { EventEmitter } from "events";
import { getStatusCodeFromError, UploadThingError as UploadThingError3 } from "@uploadthing/shared";

// src/sdk/index.ts
import { generateUploadThingURL as generateUploadThingURL2, UploadThingError as UploadThingError2 } from "@uploadthing/shared";

// src/sdk/utils.ts
import {
  generateUploadThingURL,
  pollForFileData,
  UploadThingError
} from "@uploadthing/shared";
function guardServerOnly() {
  if (typeof window !== "undefined") {
    throw new UploadThingError({
      code: "INTERNAL_SERVER_ERROR",
      message: "The `utapi` can only be used on the server."
    });
  }
}
function getApiKeyOrThrow(apiKey) {
  if (apiKey)
    return apiKey;
  if (process.env.UPLOADTHING_SECRET)
    return process.env.UPLOADTHING_SECRET;
  throw new UploadThingError({
    code: "MISSING_ENV",
    message: "Missing `UPLOADTHING_SECRET` env variable."
  });
}
var uploadFilesInternal = async (data, opts) => {
  const fileData = data.files.map((file) => ({
    name: file.name ?? "unnamed-blob",
    type: file.type,
    size: file.size
  }));
  const res = await opts.fetch(generateUploadThingURL("/api/uploadFiles"), {
    method: "POST",
    headers: opts.utRequestHeaders,
    cache: "no-store",
    body: JSON.stringify({
      files: fileData,
      metadata: data.metadata,
      contentDisposition: data.contentDisposition
    })
  });
  if (!res.ok) {
    const error = await UploadThingError.fromResponse(res);
    throw error;
  }
  const clonedRes = res.clone();
  const json = await res.json();
  if ("error" in json) {
    const error = await UploadThingError.fromResponse(clonedRes);
    throw error;
  }
  const uploads = await Promise.allSettled(
    data.files.map(async (file, i) => {
      const { presignedUrls, key, fileUrl, uploadId, chunkSize } = json.data[i];
      if (!presignedUrls || !Array.isArray(presignedUrls)) {
        throw new UploadThingError({
          code: "URL_GENERATION_FAILED",
          message: "Failed to generate presigned URL",
          cause: JSON.stringify(json.data[i])
        });
      }
      const etags = await Promise.all(
        presignedUrls.map(async (url, index) => {
          const offset = chunkSize * index;
          const end = Math.min(offset + chunkSize, file.size);
          const chunk = file.slice(offset, end);
          const etag = await uploadPart({
            fetch: opts.fetch,
            url,
            chunk,
            contentDisposition: data.contentDisposition,
            contentType: file.type,
            fileName: file.name,
            maxRetries: 10,
            key,
            utRequestHeaders: opts.utRequestHeaders
          });
          return { tag: etag, partNumber: index + 1 };
        })
      );
      await opts.fetch(generateUploadThingURL("/api/completeMultipart"), {
        method: "POST",
        body: JSON.stringify({
          fileKey: key,
          uploadId,
          etags
        }),
        headers: opts.utRequestHeaders
      });
      await pollForFileData({
        url: generateUploadThingURL(`/api/pollUpload/${key}`),
        apiKey: opts.utRequestHeaders["x-uploadthing-api-key"],
        sdkVersion: UPLOADTHING_VERSION
      });
      return {
        key,
        url: fileUrl,
        name: file.name,
        size: file.size
      };
    })
  );
  return uploads.map((upload) => {
    if (upload.status === "fulfilled") {
      const data2 = upload.value;
      return { data: data2, error: null };
    }
    const reason = upload.reason;
    const error = UploadThingError.toObject(reason);
    return { data: null, error };
  });
};

// src/sdk/index.ts
var UTApi = class {
  constructor(opts) {
    this.fetch = (opts == null ? void 0 : opts.fetch) ?? globalThis.fetch;
    this.apiKey = (opts == null ? void 0 : opts.apiKey) ?? process.env.UPLOADTHING_SECRET;
    this.defaultHeaders = {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": this.apiKey,
      "x-uploadthing-version": UPLOADTHING_VERSION
    };
    guardServerOnly();
    getApiKeyOrThrow(this.apiKey);
    incompatibleNodeGuard();
  }
  async requestUploadThing(pathname, body, fallbackErrorMessage) {
    const res = await this.fetch(generateUploadThingURL2(pathname), {
      method: "POST",
      cache: "no-store",
      headers: this.defaultHeaders,
      body: JSON.stringify(body)
    });
    const json = await res.json();
    if (!res.ok || "error" in json) {
      console.error("[UT] Error:", json);
      throw new UploadThingError2({
        code: "INTERNAL_SERVER_ERROR",
        message: "error" in json && typeof json.error === "string" ? json.error : fallbackErrorMessage
      });
    }
    return json;
  }
  /**
   * @param {FileEsque | FileEsque[]} files The file(s) to upload
   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)
   *
   * @example
   * await uploadFiles(new File(["foo"], "foo.txt"));
   *
   * @example
   * await uploadFiles([
   *   new File(["foo"], "foo.txt"),
   *   new File(["bar"], "bar.txt"),
   * ]);
   */
  async uploadFiles(files, opts) {
    guardServerOnly();
    const filesToUpload = Array.isArray(files) ? files : [files];
    const uploads = await uploadFilesInternal(
      {
        files: filesToUpload,
        metadata: (opts == null ? void 0 : opts.metadata) ?? {},
        contentDisposition: (opts == null ? void 0 : opts.contentDisposition) ?? "inline"
      },
      {
        fetch: this.fetch,
        utRequestHeaders: this.defaultHeaders
      }
    );
    const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];
    return uploadFileResponse;
  }
  /**
   * @param {string} url The URL of the file to upload
   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)
   *
   * @example
   * await uploadFileFromUrl("https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await uploadFileFromUrl([
   *   "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg",
   *   "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"
   * ])
   */
  async uploadFilesFromUrl(urls, opts) {
    guardServerOnly();
    const fileUrls = Array.isArray(urls) ? urls : [urls];
    const formData = new FormData();
    formData.append("metadata", JSON.stringify((opts == null ? void 0 : opts.metadata) ?? {}));
    const filesToUpload = await Promise.all(
      fileUrls.map(async (url) => {
        if (typeof url === "string")
          url = new URL(url);
        const filename = url.pathname.split("/").pop() ?? "unknown-filename";
        const fileResponse = await fetch(url);
        if (!fileResponse.ok) {
          throw new UploadThingError2({
            code: "BAD_REQUEST",
            message: "Failed to download requested file.",
            cause: fileResponse
          });
        }
        const blob = await fileResponse.blob();
        return Object.assign(blob, { name: filename });
      })
    );
    const uploads = await uploadFilesInternal(
      {
        files: filesToUpload,
        metadata: (opts == null ? void 0 : opts.metadata) ?? {},
        contentDisposition: (opts == null ? void 0 : opts.contentDisposition) ?? "inline"
      },
      {
        fetch: this.fetch,
        utRequestHeaders: this.defaultHeaders
      }
    );
    const uploadFileResponse = Array.isArray(urls) ? uploads : uploads[0];
    return uploadFileResponse;
  }
  /**
   * Request to delete files from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * await deleteFiles("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await deleteFiles(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   */
  async deleteFiles(fileKeys) {
    guardServerOnly();
    if (!Array.isArray(fileKeys))
      fileKeys = [fileKeys];
    return this.requestUploadThing(
      "/api/deleteFile",
      { fileKeys },
      "An unknown error occured while deleting files."
    );
  }
  /**
   * Request file URLs from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * const data = await getFileUrls("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   * console.log(data); // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg"}]
   *
   * @example
   * const data = await getFileUrls(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   * console.log(data) // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg" },{key: "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg", url: "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"}]
   */
  async getFileUrls(fileKeys) {
    guardServerOnly();
    if (!Array.isArray(fileKeys))
      fileKeys = [fileKeys];
    const json = await this.requestUploadThing(
      "/api/getFileUrl",
      { fileKeys },
      "An unknown error occured while retrieving file URLs."
    );
    return json.data;
  }
  /**
   * Request file list from UploadThing storage.
   *
   * @example
   * const data = await listFiles();
   * console.log(data); // { key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", id: "2e0fdb64-9957-4262-8e45-f372ba903ac8" }
   */
  async listFiles() {
    guardServerOnly();
    const json = await this.requestUploadThing("/api/listFiles", {}, "An unknown error occured while listing files.");
    return json.files;
  }
  async renameFile(updates) {
    guardServerOnly();
    if (!Array.isArray(updates))
      updates = [updates];
    return this.requestUploadThing(
      "/api/renameFile",
      { updates },
      "An unknown error occured while renaming files."
    );
  }
  async getUsageInfo() {
    guardServerOnly();
    return this.requestUploadThing(
      "/api/getUsageInfo",
      {},
      "An unknown error occured while getting usage info."
    );
  }
};

// src/server.ts
var createUploadthing = (opts) => createBuilder(opts);
var createServerHandler = (opts) => {
  incompatibleNodeGuard();
  const ee = new EventEmitter();
  const requestHandler = buildRequestHandler(opts, ee);
  const POST = async (request) => {
    const req = request instanceof Request ? request : request.request;
    const response = await requestHandler({ req });
    if (response instanceof UploadThingError3) {
      return new Response(JSON.stringify(formatError(response, opts.router)), {
        status: getStatusCodeFromError(response),
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    if (response.status !== 200) {
      return new Response("An unknown error occured", {
        status: 500,
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    return new Response(JSON.stringify(response.body), {
      status: response.status,
      headers: {
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
  };
  const getBuildPerms = buildPermissionsInfoHandler(opts);
  const GET = async (request) => {
    const req = request instanceof Request ? request : request.request;
    const clientPollingKey = req.headers.get("x-uploadthing-polling-key");
    if (clientPollingKey) {
      const eventData = await new Promise((resolve) => {
        ee.addListener("callbackDone", resolve);
      });
      ee.removeAllListeners("callbackDone");
      return new Response(JSON.stringify(eventData), {
        status: 200,
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    return new Response(JSON.stringify(getBuildPerms()), {
      status: 200,
      headers: {
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
  };
  return { GET, POST };
};
var extractRouterConfig = (router) => buildPermissionsInfoHandler({ router })();

export {
  UTApi,
  createUploadthing,
  createServerHandler,
  extractRouterConfig
};
//# sourceMappingURL=chunk-QL6VJUCG.mjs.map