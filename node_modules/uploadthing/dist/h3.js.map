{"version":3,"sources":["../src/h3.ts","../../../node_modules/.pnpm/destr@2.0.1/node_modules/destr/dist/index.mjs","../../../node_modules/.pnpm/defu@6.1.2/node_modules/defu/dist/defu.mjs","../../../node_modules/.pnpm/h3@1.8.1/node_modules/h3/dist/index.mjs","../package.json","../src/constants.ts","../src/internal/error-formatter.ts","../src/internal/handler.ts","../src/internal/dev-hook.ts","../src/internal/parser.ts","../src/internal/types.ts","../src/internal/upload-builder.ts"],"sourcesContent":["import EventEmitter from \"events\";\nimport type { H3Event } from \"h3\";\nimport {\n  assertMethod,\n  defineEventHandler,\n  getRequestHeaders,\n  getRequestURL,\n  readBody,\n  setHeaders,\n  setResponseStatus,\n} from \"h3\";\n\nimport type { Json } from \"@uploadthing/shared\";\nimport { getStatusCodeFromError, UploadThingError } from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"./constants\";\nimport { defaultErrorFormatter } from \"./internal/error-formatter\";\nimport {\n  buildPermissionsInfoHandler,\n  buildRequestHandler,\n} from \"./internal/handler\";\nimport type { RouterWithConfig } from \"./internal/handler\";\nimport type { FileRouter } from \"./internal/types\";\nimport type { CreateBuilderOptions } from \"./internal/upload-builder\";\nimport { createBuilder } from \"./internal/upload-builder\";\n\nexport type { FileRouter } from \"./internal/types\";\n\nexport const createUploadthing = <TErrorShape extends Json>(\n  opts?: CreateBuilderOptions<TErrorShape>,\n) =>\n  createBuilder<\n    { req: undefined; res: undefined; event: H3Event },\n    TErrorShape\n  >(opts);\n\nexport const createH3EventHandler = <TRouter extends FileRouter>(\n  opts: RouterWithConfig<TRouter>,\n) => {\n  const ee = new EventEmitter();\n  const requestHandler = buildRequestHandler(opts, ee);\n  const getBuildPerms = buildPermissionsInfoHandler<TRouter>(opts);\n\n  return defineEventHandler(async (event) => {\n    assertMethod(event, [\"GET\", \"POST\"]);\n    setHeaders(event, { \"x-uploadthing-version\": UPLOADTHING_VERSION });\n\n    // GET\n    if (event.method === \"GET\") {\n      const clientPollingKey =\n        getRequestHeaders(event)[\"x-uploadthing-polling\"];\n      if (clientPollingKey) {\n        const eventData = await new Promise((resolve) => {\n          ee.addListener(\"callbackDone\", resolve);\n        });\n        ee.removeAllListeners(\"callbackDone\");\n        return eventData;\n      }\n\n      return getBuildPerms();\n    }\n\n    // POST\n    const response = await requestHandler({\n      req: {\n        url: getRequestURL(event).href,\n        headers: getRequestHeaders(event),\n        json: () => Promise.resolve(readBody(event)),\n      },\n      event,\n    });\n\n    if (response instanceof UploadThingError) {\n      setResponseStatus(event, getStatusCodeFromError(response));\n      const errorFormatter =\n        opts.router[Object.keys(opts.router)[0]]?._def.errorFormatter ??\n        defaultErrorFormatter;\n      return errorFormatter(response) as unknown;\n    }\n\n    if (response.status !== 200) {\n      // We messed up - this should never happen\n      setResponseStatus(event, 500);\n      return \"An unknown error occurred\";\n    }\n\n    return response.body;\n  });\n};\n","const suspectProtoRx = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^\\s*[\"[{]|^\\s*-?\\d[\\d.]{0,14}\\s*$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\" || key === \"constructor\" && value && typeof value === \"object\" && \"prototype\" in value) {\n    warnKeyDropped(key);\n    return;\n  }\n  return value;\n}\nfunction warnKeyDropped(key) {\n  console.warn(`[destr] Dropping \"${key}\" key to prevent prototype pollution.`);\n}\nfunction destr(value, options = {}) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  const _value = value.trim();\n  if (value[0] === '\"' && value[value.length - 1] === '\"') {\n    return _value.slice(1, -1);\n  }\n  if (_value.length <= 9) {\n    const _lval = _value.toLowerCase();\n    if (_lval === \"true\") {\n      return true;\n    }\n    if (_lval === \"false\") {\n      return false;\n    }\n    if (_lval === \"undefined\") {\n      return void 0;\n    }\n    if (_lval === \"null\") {\n      return null;\n    }\n    if (_lval === \"nan\") {\n      return Number.NaN;\n    }\n    if (_lval === \"infinity\") {\n      return Number.POSITIVE_INFINITY;\n    }\n    if (_lval === \"-infinity\") {\n      return Number.NEGATIVE_INFINITY;\n    }\n  }\n  if (!JsonSigRx.test(value)) {\n    if (options.strict) {\n      throw new SyntaxError(\"[destr] Invalid JSON\");\n    }\n    return value;\n  }\n  try {\n    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {\n      if (options.strict) {\n        throw new Error(\"[destr] Possible prototype pollution\");\n      }\n      return JSON.parse(value, jsonParseTransform);\n    }\n    return JSON.parse(value);\n  } catch (error) {\n    if (options.strict) {\n      throw error;\n    }\n    return value;\n  }\n}\nfunction safeDestr(value, options = {}) {\n  return destr(value, { ...options, strict: true });\n}\n\nexport { destr as default, destr, safeDestr };\n","function isObject(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isObject(value) && isObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue) => {\n  if (typeof object[key] !== \"undefined\" && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n","import { withoutTrailingSlash, withoutBase, getQuery as getQuery$1, decodePath, withLeadingSlash, parseURL } from 'ufo';\nimport { parse as parse$1, serialize } from 'cookie-es';\nimport { createRouter as createRouter$1, toRouteMatcher } from 'radix3';\nimport destr from 'destr';\nimport { defu } from 'defu';\nimport crypto from 'uncrypto';\nimport { seal, defaults, unseal } from 'iron-webcrypto';\nimport { IncomingMessage } from 'unenv/runtime/node/http/_request';\nimport { ServerResponse } from 'unenv/runtime/node/http/_response';\n\nfunction useBase(base, handler) {\n  base = withoutTrailingSlash(base);\n  if (!base || base === \"/\") {\n    return handler;\n  }\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const _path = event._path || event.node.req.url || \"/\";\n    event._path = withoutBase(event.path || \"/\", base);\n    event.node.req.url = event._path;\n    try {\n      return await handler(event);\n    } finally {\n      event._path = event.node.req.url = _path;\n    }\n  });\n}\n\nfunction hasProp(obj, prop) {\n  try {\n    return prop in obj;\n  } catch {\n    return false;\n  }\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass H3Error extends Error {\n  constructor(message, opts = {}) {\n    super(message, opts);\n    __publicField$1(this, \"statusCode\", 500);\n    __publicField$1(this, \"fatal\", false);\n    __publicField$1(this, \"unhandled\", false);\n    __publicField$1(this, \"statusMessage\");\n    __publicField$1(this, \"data\");\n    __publicField$1(this, \"cause\");\n    if (opts.cause && !this.cause) {\n      this.cause = opts.cause;\n    }\n  }\n  toJSON() {\n    const obj = {\n      message: this.message,\n      statusCode: sanitizeStatusCode(this.statusCode, 500)\n    };\n    if (this.statusMessage) {\n      obj.statusMessage = sanitizeStatusMessage(this.statusMessage);\n    }\n    if (this.data !== void 0) {\n      obj.data = this.data;\n    }\n    return obj;\n  }\n}\n__publicField$1(H3Error, \"__h3_error__\", true);\nfunction createError(input) {\n  if (typeof input === \"string\") {\n    return new H3Error(input);\n  }\n  if (isError(input)) {\n    return input;\n  }\n  const err = new H3Error(input.message ?? input.statusMessage ?? \"\", {\n    cause: input.cause || input\n  });\n  if (hasProp(input, \"stack\")) {\n    try {\n      Object.defineProperty(err, \"stack\", {\n        get() {\n          return input.stack;\n        }\n      });\n    } catch {\n      try {\n        err.stack = input.stack;\n      } catch {\n      }\n    }\n  }\n  if (input.data) {\n    err.data = input.data;\n  }\n  if (input.statusCode) {\n    err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);\n  } else if (input.status) {\n    err.statusCode = sanitizeStatusCode(input.status, err.statusCode);\n  }\n  if (input.statusMessage) {\n    err.statusMessage = input.statusMessage;\n  } else if (input.statusText) {\n    err.statusMessage = input.statusText;\n  }\n  if (err.statusMessage) {\n    const originalMessage = err.statusMessage;\n    const sanitizedMessage = sanitizeStatusMessage(err.statusMessage);\n    if (sanitizedMessage !== originalMessage) {\n      console.warn(\n        \"[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.\"\n      );\n    }\n  }\n  if (input.fatal !== void 0) {\n    err.fatal = input.fatal;\n  }\n  if (input.unhandled !== void 0) {\n    err.unhandled = input.unhandled;\n  }\n  return err;\n}\nfunction sendError(event, error, debug) {\n  if (event.handled) {\n    return;\n  }\n  const h3Error = isError(error) ? error : createError(error);\n  const responseBody = {\n    statusCode: h3Error.statusCode,\n    statusMessage: h3Error.statusMessage,\n    stack: [],\n    data: h3Error.data\n  };\n  if (debug) {\n    responseBody.stack = (h3Error.stack || \"\").split(\"\\n\").map((l) => l.trim());\n  }\n  if (event.handled) {\n    return;\n  }\n  const _code = Number.parseInt(h3Error.statusCode);\n  setResponseStatus(event, _code, h3Error.statusMessage);\n  event.node.res.setHeader(\"content-type\", MIMES.json);\n  event.node.res.end(JSON.stringify(responseBody, void 0, 2));\n}\nfunction isError(input) {\n  return input?.constructor?.__h3_error__ === true;\n}\n\nfunction parse(multipartBodyBuffer, boundary) {\n  let lastline = \"\";\n  let state = 0 /* INIT */;\n  let buffer = [];\n  const allParts = [];\n  let currentPartHeaders = [];\n  for (let i = 0; i < multipartBodyBuffer.length; i++) {\n    const prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;\n    const currByte = multipartBodyBuffer[i];\n    const newLineChar = currByte === 10 || currByte === 13;\n    if (!newLineChar) {\n      lastline += String.fromCodePoint(currByte);\n    }\n    const newLineDetected = currByte === 10 && prevByte === 13;\n    if (0 /* INIT */ === state && newLineDetected) {\n      if (\"--\" + boundary === lastline) {\n        state = 1 /* READING_HEADERS */;\n      }\n      lastline = \"\";\n    } else if (1 /* READING_HEADERS */ === state && newLineDetected) {\n      if (lastline.length > 0) {\n        const i2 = lastline.indexOf(\":\");\n        if (i2 > 0) {\n          const name = lastline.slice(0, i2).toLowerCase();\n          const value = lastline.slice(i2 + 1).trim();\n          currentPartHeaders.push([name, value]);\n        }\n      } else {\n        state = 2 /* READING_DATA */;\n        buffer = [];\n      }\n      lastline = \"\";\n    } else if (2 /* READING_DATA */ === state) {\n      if (lastline.length > boundary.length + 4) {\n        lastline = \"\";\n      }\n      if (\"--\" + boundary === lastline) {\n        const j = buffer.length - lastline.length;\n        const part = buffer.slice(0, j - 1);\n        allParts.push(process(part, currentPartHeaders));\n        buffer = [];\n        currentPartHeaders = [];\n        lastline = \"\";\n        state = 3 /* READING_PART_SEPARATOR */;\n      } else {\n        buffer.push(currByte);\n      }\n      if (newLineDetected) {\n        lastline = \"\";\n      }\n    } else if (3 /* READING_PART_SEPARATOR */ === state && newLineDetected) {\n      state = 1 /* READING_HEADERS */;\n    }\n  }\n  return allParts;\n}\nfunction process(data, headers) {\n  const dataObj = {};\n  const contentDispositionHeader = headers.find((h) => h[0] === \"content-disposition\")?.[1] || \"\";\n  for (const i of contentDispositionHeader.split(\";\")) {\n    const s = i.split(\"=\");\n    if (s.length !== 2) {\n      continue;\n    }\n    const key = (s[0] || \"\").trim();\n    if (key === \"name\" || key === \"filename\") {\n      const _value = (s[1] || \"\").trim().replace(/\"/g, \"\");\n      dataObj[key] = Buffer.from(_value, \"latin1\").toString(\"utf8\");\n    }\n  }\n  const contentType = headers.find((h) => h[0] === \"content-type\")?.[1] || \"\";\n  if (contentType) {\n    dataObj.type = contentType;\n  }\n  dataObj.data = Buffer.from(data);\n  return dataObj;\n}\n\nasync function validateData(data, fn) {\n  try {\n    const res = await fn(data);\n    if (res === false) {\n      throw createValidationError();\n    }\n    if (res === true) {\n      return data;\n    }\n    return res ?? data;\n  } catch (error) {\n    throw createValidationError(error);\n  }\n}\nfunction createValidationError(validateError) {\n  throw createError({\n    status: 400,\n    message: validateError.message || \"Validation Failed\",\n    ...validateError\n  });\n}\n\nfunction getQuery(event) {\n  return getQuery$1(event.path || \"\");\n}\nfunction getValidatedQuery(event, validate) {\n  const query = getQuery(event);\n  return validateData(query, validate);\n}\nfunction getRouterParams(event) {\n  return event.context.params || {};\n}\nfunction getRouterParam(event, name) {\n  const params = getRouterParams(event);\n  return params[name];\n}\nfunction getMethod(event, defaultMethod = \"GET\") {\n  return (event.node.req.method || defaultMethod).toUpperCase();\n}\nfunction isMethod(event, expected, allowHead) {\n  if (allowHead && event.method === \"HEAD\") {\n    return true;\n  }\n  if (typeof expected === \"string\") {\n    if (event.method === expected) {\n      return true;\n    }\n  } else if (expected.includes(event.method)) {\n    return true;\n  }\n  return false;\n}\nfunction assertMethod(event, expected, allowHead) {\n  if (!isMethod(event, expected, allowHead)) {\n    throw createError({\n      statusCode: 405,\n      statusMessage: \"HTTP method is not allowed.\"\n    });\n  }\n}\nfunction getRequestHeaders(event) {\n  const _headers = {};\n  for (const key in event.node.req.headers) {\n    const val = event.node.req.headers[key];\n    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(\", \") : val;\n  }\n  return _headers;\n}\nconst getHeaders = getRequestHeaders;\nfunction getRequestHeader(event, name) {\n  const headers = getRequestHeaders(event);\n  const value = headers[name.toLowerCase()];\n  return value;\n}\nconst getHeader = getRequestHeader;\nfunction getRequestHost(event, opts = {}) {\n  if (opts.xForwardedHost) {\n    const xForwardedHost = event.node.req.headers[\"x-forwarded-host\"];\n    if (xForwardedHost) {\n      return xForwardedHost;\n    }\n  }\n  return event.node.req.headers.host || \"localhost\";\n}\nfunction getRequestProtocol(event, opts = {}) {\n  if (opts.xForwardedProto !== false && event.node.req.headers[\"x-forwarded-proto\"] === \"https\") {\n    return \"https\";\n  }\n  return event.node.req.connection.encrypted ? \"https\" : \"http\";\n}\nconst DOUBLE_SLASH_RE = /[/\\\\]{2,}/g;\nfunction getRequestPath(event) {\n  const path = (event.node.req.url || \"/\").replace(DOUBLE_SLASH_RE, \"/\");\n  return path;\n}\nfunction getRequestURL(event, opts = {}) {\n  const host = getRequestHost(event, opts);\n  const protocol = getRequestProtocol(event);\n  const path = (event.node.req.originalUrl || event.path).replace(\n    /^[/\\\\]+/g,\n    \"/\"\n  );\n  return new URL(path, `${protocol}://${host}`);\n}\nfunction toWebRequest(event) {\n  return event.web?.request || new Request(getRequestURL(event), {\n    // @ts-ignore Undici option\n    duplex: \"half\",\n    method: event.method,\n    headers: event.headers,\n    body: getRequestWebStream(event)\n  });\n}\nfunction getRequestIP(event, opts = {}) {\n  if (event.context.clientAddress) {\n    return event.context.clientAddress;\n  }\n  if (opts.xForwardedFor) {\n    const xForwardedFor = getRequestHeader(event, \"x-forwarded-for\")?.split(\",\")?.pop();\n    if (xForwardedFor) {\n      return xForwardedFor;\n    }\n  }\n  if (event.node.req.socket.remoteAddress) {\n    return event.node.req.socket.remoteAddress;\n  }\n}\n\nconst RawBodySymbol = Symbol.for(\"h3RawBody\");\nconst ParsedBodySymbol = Symbol.for(\"h3ParsedBody\");\nconst PayloadMethods$1 = [\"PATCH\", \"POST\", \"PUT\", \"DELETE\"];\nfunction readRawBody(event, encoding = \"utf8\") {\n  assertMethod(event, PayloadMethods$1);\n  const _rawBody = event._requestBody || event.web?.request?.body || event.node.req[RawBodySymbol] || event.node.req.body;\n  if (_rawBody) {\n    const promise2 = Promise.resolve(_rawBody).then((_resolved) => {\n      if (Buffer.isBuffer(_resolved)) {\n        return _resolved;\n      }\n      if (typeof _resolved.pipeTo === \"function\") {\n        return new Promise((resolve, reject) => {\n          const chunks = [];\n          _resolved.pipeTo(\n            new WritableStream({\n              write(chunk) {\n                chunks.push(chunk);\n              },\n              close() {\n                resolve(Buffer.concat(chunks));\n              },\n              abort(reason) {\n                reject(reason);\n              }\n            })\n          ).catch(reject);\n        });\n      } else if (typeof _resolved.pipe === \"function\") {\n        return new Promise((resolve, reject) => {\n          const chunks = [];\n          _resolved.on(\"data\", (chunk) => {\n            chunks.push(chunk);\n          }).on(\"end\", () => {\n            resolve(Buffer.concat(chunks));\n          }).on(\"error\", reject);\n        });\n      }\n      if (_resolved.constructor === Object) {\n        return Buffer.from(JSON.stringify(_resolved));\n      }\n      return Buffer.from(_resolved);\n    });\n    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;\n  }\n  if (!Number.parseInt(event.node.req.headers[\"content-length\"] || \"\")) {\n    return Promise.resolve(void 0);\n  }\n  const promise = event.node.req[RawBodySymbol] = new Promise(\n    (resolve, reject) => {\n      const bodyData = [];\n      event.node.req.on(\"error\", (err) => {\n        reject(err);\n      }).on(\"data\", (chunk) => {\n        bodyData.push(chunk);\n      }).on(\"end\", () => {\n        resolve(Buffer.concat(bodyData));\n      });\n    }\n  );\n  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;\n  return result;\n}\nasync function readBody(event, options = {}) {\n  const request = event.node.req;\n  if (hasProp(request, ParsedBodySymbol)) {\n    return request[ParsedBodySymbol];\n  }\n  const contentType = request.headers[\"content-type\"] || \"\";\n  const body = await readRawBody(event);\n  let parsed;\n  if (contentType === \"application/json\") {\n    parsed = _parseJSON(body, options.strict ?? true);\n  } else if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n    parsed = _parseURLEncodedBody(body);\n  } else if (contentType.startsWith(\"text/\")) {\n    parsed = body;\n  } else {\n    parsed = _parseJSON(body, options.strict ?? false);\n  }\n  request[ParsedBodySymbol] = parsed;\n  return parsed;\n}\nasync function readValidatedBody(event, validate) {\n  const _body = await readBody(event, { strict: true });\n  return validateData(_body, validate);\n}\nasync function readMultipartFormData(event) {\n  const contentType = getRequestHeader(event, \"content-type\");\n  if (!contentType || !contentType.startsWith(\"multipart/form-data\")) {\n    return;\n  }\n  const boundary = contentType.match(/boundary=([^;]*)(;|$)/i)?.[1];\n  if (!boundary) {\n    return;\n  }\n  const body = await readRawBody(event, false);\n  if (!body) {\n    return;\n  }\n  return parse(body, boundary);\n}\nasync function readFormData(event) {\n  return await toWebRequest(event).formData();\n}\nfunction getRequestWebStream(event) {\n  if (!PayloadMethods$1.includes(event.method)) {\n    return;\n  }\n  return event.web?.request?.body || event._requestBody || new ReadableStream({\n    start: (controller) => {\n      event.node.req.on(\"data\", (chunk) => {\n        controller.enqueue(chunk);\n      });\n      event.node.req.on(\"end\", () => {\n        controller.close();\n      });\n      event.node.req.on(\"error\", (err) => {\n        controller.error(err);\n      });\n    }\n  });\n}\nfunction _parseJSON(body = \"\", strict) {\n  if (!body) {\n    return void 0;\n  }\n  try {\n    return destr(body, { strict });\n  } catch {\n    throw createError({\n      statusCode: 400,\n      statusMessage: \"Bad Request\",\n      message: \"Invalid JSON body\"\n    });\n  }\n}\nfunction _parseURLEncodedBody(body) {\n  const form = new URLSearchParams(body);\n  const parsedForm = /* @__PURE__ */ Object.create(null);\n  for (const [key, value] of form.entries()) {\n    if (hasProp(parsedForm, key)) {\n      if (!Array.isArray(parsedForm[key])) {\n        parsedForm[key] = [parsedForm[key]];\n      }\n      parsedForm[key].push(value);\n    } else {\n      parsedForm[key] = value;\n    }\n  }\n  return parsedForm;\n}\n\nfunction handleCacheHeaders(event, opts) {\n  const cacheControls = [\"public\", ...opts.cacheControls || []];\n  let cacheMatched = false;\n  if (opts.maxAge !== void 0) {\n    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);\n  }\n  if (opts.modifiedTime) {\n    const modifiedTime = new Date(opts.modifiedTime);\n    const ifModifiedSince = event.node.req.headers[\"if-modified-since\"];\n    event.node.res.setHeader(\"last-modified\", modifiedTime.toUTCString());\n    if (ifModifiedSince && new Date(ifModifiedSince) >= opts.modifiedTime) {\n      cacheMatched = true;\n    }\n  }\n  if (opts.etag) {\n    event.node.res.setHeader(\"etag\", opts.etag);\n    const ifNonMatch = event.node.req.headers[\"if-none-match\"];\n    if (ifNonMatch === opts.etag) {\n      cacheMatched = true;\n    }\n  }\n  event.node.res.setHeader(\"cache-control\", cacheControls.join(\", \"));\n  if (cacheMatched) {\n    event.node.res.statusCode = 304;\n    if (!event.handled) {\n      event.node.res.end();\n    }\n    return true;\n  }\n  return false;\n}\n\nconst MIMES = {\n  html: \"text/html\",\n  json: \"application/json\"\n};\n\nconst DISALLOWED_STATUS_CHARS = /[^\\u0009\\u0020-\\u007E]/g;\nfunction sanitizeStatusMessage(statusMessage = \"\") {\n  return statusMessage.replace(DISALLOWED_STATUS_CHARS, \"\");\n}\nfunction sanitizeStatusCode(statusCode, defaultStatusCode = 200) {\n  if (!statusCode) {\n    return defaultStatusCode;\n  }\n  if (typeof statusCode === \"string\") {\n    statusCode = Number.parseInt(statusCode, 10);\n  }\n  if (statusCode < 100 || statusCode > 999) {\n    return defaultStatusCode;\n  }\n  return statusCode;\n}\n\nfunction parseCookies(event) {\n  return parse$1(event.node.req.headers.cookie || \"\");\n}\nfunction getCookie(event, name) {\n  return parseCookies(event)[name];\n}\nfunction setCookie(event, name, value, serializeOptions) {\n  const cookieStr = serialize(name, value, {\n    path: \"/\",\n    ...serializeOptions\n  });\n  let setCookies = event.node.res.getHeader(\"set-cookie\");\n  if (!Array.isArray(setCookies)) {\n    setCookies = [setCookies];\n  }\n  setCookies = setCookies.filter((cookieValue) => {\n    return cookieValue && !cookieValue.startsWith(name + \"=\");\n  });\n  event.node.res.setHeader(\"set-cookie\", [...setCookies, cookieStr]);\n}\nfunction deleteCookie(event, name, serializeOptions) {\n  setCookie(event, name, \"\", {\n    ...serializeOptions,\n    maxAge: 0\n  });\n}\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString.flatMap((c) => splitCookiesString(c));\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n  const cookiesStrings = [];\n  let pos = 0;\n  let start;\n  let ch;\n  let lastComma;\n  let nextStart;\n  let cookiesSeparatorFound;\n  const skipWhitespace = () => {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  };\n  const notSpecialChar = () => {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  };\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.slice(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.slice(start, cookiesString.length));\n    }\n  }\n  return cookiesStrings;\n}\n\nconst defer = typeof setImmediate === \"undefined\" ? (fn) => fn() : setImmediate;\nfunction send(event, data, type) {\n  if (type) {\n    defaultContentType(event, type);\n  }\n  return new Promise((resolve) => {\n    defer(() => {\n      if (!event.handled) {\n        event.node.res.end(data);\n      }\n      resolve();\n    });\n  });\n}\nfunction sendNoContent(event, code) {\n  if (event.handled) {\n    return;\n  }\n  const _code = sanitizeStatusCode(code, 204);\n  if (_code === 204) {\n    event.node.res.removeHeader(\"content-length\");\n  }\n  event.node.res.writeHead(_code);\n  event.node.res.end();\n}\nfunction setResponseStatus(event, code, text) {\n  if (code) {\n    event.node.res.statusCode = sanitizeStatusCode(\n      code,\n      event.node.res.statusCode\n    );\n  }\n  if (text) {\n    event.node.res.statusMessage = sanitizeStatusMessage(text);\n  }\n}\nfunction getResponseStatus(event) {\n  return event.node.res.statusCode;\n}\nfunction getResponseStatusText(event) {\n  return event.node.res.statusMessage;\n}\nfunction defaultContentType(event, type) {\n  if (type && !event.node.res.getHeader(\"content-type\")) {\n    event.node.res.setHeader(\"content-type\", type);\n  }\n}\nfunction sendRedirect(event, location, code = 302) {\n  event.node.res.statusCode = sanitizeStatusCode(\n    code,\n    event.node.res.statusCode\n  );\n  event.node.res.setHeader(\"location\", location);\n  const encodedLoc = location.replace(/\"/g, \"%22\");\n  const html = `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`;\n  return send(event, html, MIMES.html);\n}\nfunction getResponseHeaders(event) {\n  return event.node.res.getHeaders();\n}\nfunction getResponseHeader(event, name) {\n  return event.node.res.getHeader(name);\n}\nfunction setResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    event.node.res.setHeader(name, value);\n  }\n}\nconst setHeaders = setResponseHeaders;\nfunction setResponseHeader(event, name, value) {\n  event.node.res.setHeader(name, value);\n}\nconst setHeader = setResponseHeader;\nfunction appendResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    appendResponseHeader(event, name, value);\n  }\n}\nconst appendHeaders = appendResponseHeaders;\nfunction appendResponseHeader(event, name, value) {\n  let current = event.node.res.getHeader(name);\n  if (!current) {\n    event.node.res.setHeader(name, value);\n    return;\n  }\n  if (!Array.isArray(current)) {\n    current = [current.toString()];\n  }\n  event.node.res.setHeader(name, [...current, value]);\n}\nconst appendHeader = appendResponseHeader;\nfunction clearResponseHeaders(event, headerNames) {\n  if (headerNames && headerNames.length > 0) {\n    for (const name of headerNames) {\n      removeResponseHeader(event, name);\n    }\n  } else {\n    for (const [name] of Object.entries(getResponseHeaders(event))) {\n      removeResponseHeader(event, name);\n    }\n  }\n}\nfunction removeResponseHeader(event, name) {\n  return event.node.res.removeHeader(name);\n}\nfunction isStream(data) {\n  if (!data || typeof data !== \"object\") {\n    return false;\n  }\n  if (typeof data.pipe === \"function\") {\n    if (typeof data._read === \"function\") {\n      return true;\n    }\n    if (typeof data.abort === \"function\") {\n      return true;\n    }\n  }\n  if (typeof data.pipeTo === \"function\") {\n    return true;\n  }\n  return false;\n}\nfunction isWebResponse(data) {\n  return typeof Response !== \"undefined\" && data instanceof Response;\n}\nfunction sendStream(event, stream) {\n  if (!stream || typeof stream !== \"object\") {\n    throw new Error(\"[h3] Invalid stream provided.\");\n  }\n  event.node.res._data = stream;\n  if (!event.node.res.socket) {\n    event._handled = true;\n    return Promise.resolve();\n  }\n  if (hasProp(stream, \"pipeTo\") && typeof stream.pipeTo === \"function\") {\n    return stream.pipeTo(\n      new WritableStream({\n        write(chunk) {\n          event.node.res.write(chunk);\n        }\n      })\n    ).then(() => {\n      event.node.res.end();\n    });\n  }\n  if (hasProp(stream, \"pipe\") && typeof stream.pipe === \"function\") {\n    return new Promise((resolve, reject) => {\n      stream.pipe(event.node.res);\n      if (stream.on) {\n        stream.on(\"end\", () => {\n          event.node.res.end();\n          resolve();\n        });\n        stream.on(\"error\", (error) => {\n          reject(error);\n        });\n      }\n      event.node.res.on(\"close\", () => {\n        if (stream.abort) {\n          stream.abort();\n        }\n      });\n    });\n  }\n  throw new Error(\"[h3] Invalid or incompatible stream provided.\");\n}\nconst noop = () => {\n};\nfunction writeEarlyHints(event, hints, cb = noop) {\n  if (!event.node.res.socket) {\n    cb();\n    return;\n  }\n  if (typeof hints === \"string\" || Array.isArray(hints)) {\n    hints = { link: hints };\n  }\n  if (hints.link) {\n    hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(\",\");\n  }\n  const headers = Object.entries(hints).map(\n    (e) => [e[0].toLowerCase(), e[1]]\n  );\n  if (headers.length === 0) {\n    cb();\n    return;\n  }\n  let hint = \"HTTP/1.1 103 Early Hints\";\n  if (hints.link) {\n    hint += `\\r\nLink: ${hints.link.join(\", \")}`;\n  }\n  for (const [header, value] of headers) {\n    if (header === \"link\") {\n      continue;\n    }\n    hint += `\\r\n${header}: ${value}`;\n  }\n  if (event.node.res.socket) {\n    event.node.res.socket.write(\n      `${hint}\\r\n\\r\n`,\n      \"utf8\",\n      cb\n    );\n  } else {\n    cb();\n  }\n}\nfunction sendWebResponse(event, response) {\n  for (const [key, value] of response.headers) {\n    if (key === \"set-cookie\") {\n      event.node.res.appendHeader(key, splitCookiesString(value));\n    } else {\n      event.node.res.setHeader(key, value);\n    }\n  }\n  if (response.status) {\n    event.node.res.statusCode = sanitizeStatusCode(\n      response.status,\n      event.node.res.statusCode\n    );\n  }\n  if (response.statusText) {\n    event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\n  }\n  if (response.redirected) {\n    event.node.res.setHeader(\"location\", response.url);\n  }\n  if (!response.body) {\n    event.node.res.end();\n    return;\n  }\n  return sendStream(event, response.body);\n}\n\nfunction resolveCorsOptions(options = {}) {\n  const defaultOptions = {\n    origin: \"*\",\n    methods: \"*\",\n    allowHeaders: \"*\",\n    exposeHeaders: \"*\",\n    credentials: false,\n    maxAge: false,\n    preflight: {\n      statusCode: 204\n    }\n  };\n  return defu(options, defaultOptions);\n}\nfunction isPreflightRequest(event) {\n  const origin = getRequestHeader(event, \"origin\");\n  const accessControlRequestMethod = getRequestHeader(\n    event,\n    \"access-control-request-method\"\n  );\n  return event.method === \"OPTIONS\" && !!origin && !!accessControlRequestMethod;\n}\nfunction isCorsOriginAllowed(origin, options) {\n  const { origin: originOption } = options;\n  if (!origin || !originOption || originOption === \"*\" || originOption === \"null\") {\n    return true;\n  }\n  if (Array.isArray(originOption)) {\n    return originOption.some((_origin) => {\n      if (_origin instanceof RegExp) {\n        return _origin.test(origin);\n      }\n      return origin === _origin;\n    });\n  }\n  return originOption(origin);\n}\nfunction createOriginHeaders(event, options) {\n  const { origin: originOption } = options;\n  const origin = getRequestHeader(event, \"origin\");\n  if (!origin || !originOption || originOption === \"*\") {\n    return { \"access-control-allow-origin\": \"*\" };\n  }\n  if (typeof originOption === \"string\") {\n    return { \"access-control-allow-origin\": originOption, vary: \"origin\" };\n  }\n  return isCorsOriginAllowed(origin, options) ? { \"access-control-allow-origin\": origin, vary: \"origin\" } : {};\n}\nfunction createMethodsHeaders(options) {\n  const { methods } = options;\n  if (!methods) {\n    return {};\n  }\n  if (methods === \"*\") {\n    return { \"access-control-allow-methods\": \"*\" };\n  }\n  return methods.length > 0 ? { \"access-control-allow-methods\": methods.join(\",\") } : {};\n}\nfunction createCredentialsHeaders(options) {\n  const { credentials } = options;\n  if (credentials) {\n    return { \"access-control-allow-credentials\": \"true\" };\n  }\n  return {};\n}\nfunction createAllowHeaderHeaders(event, options) {\n  const { allowHeaders } = options;\n  if (!allowHeaders || allowHeaders === \"*\" || allowHeaders.length === 0) {\n    const header = getRequestHeader(event, \"access-control-request-headers\");\n    return header ? {\n      \"access-control-allow-headers\": header,\n      vary: \"access-control-request-headers\"\n    } : {};\n  }\n  return {\n    \"access-control-allow-headers\": allowHeaders.join(\",\"),\n    vary: \"access-control-request-headers\"\n  };\n}\nfunction createExposeHeaders(options) {\n  const { exposeHeaders } = options;\n  if (!exposeHeaders) {\n    return {};\n  }\n  if (exposeHeaders === \"*\") {\n    return { \"access-control-expose-headers\": exposeHeaders };\n  }\n  return { \"access-control-expose-headers\": exposeHeaders.join(\",\") };\n}\nfunction appendCorsPreflightHeaders(event, options) {\n  appendHeaders(event, createOriginHeaders(event, options));\n  appendHeaders(event, createCredentialsHeaders(options));\n  appendHeaders(event, createExposeHeaders(options));\n  appendHeaders(event, createMethodsHeaders(options));\n  appendHeaders(event, createAllowHeaderHeaders(event, options));\n}\nfunction appendCorsHeaders(event, options) {\n  appendHeaders(event, createOriginHeaders(event, options));\n  appendHeaders(event, createCredentialsHeaders(options));\n  appendHeaders(event, createExposeHeaders(options));\n}\n\nfunction handleCors(event, options) {\n  const _options = resolveCorsOptions(options);\n  if (isPreflightRequest(event)) {\n    appendCorsPreflightHeaders(event, options);\n    sendNoContent(event, _options.preflight.statusCode);\n    return true;\n  }\n  appendCorsHeaders(event, options);\n  return false;\n}\n\nconst PayloadMethods = /* @__PURE__ */ new Set([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]);\nconst ignoredHeaders = /* @__PURE__ */ new Set([\n  \"transfer-encoding\",\n  \"connection\",\n  \"keep-alive\",\n  \"upgrade\",\n  \"expect\",\n  \"host\"\n]);\nasync function proxyRequest(event, target, opts = {}) {\n  let body;\n  let duplex;\n  if (PayloadMethods.has(event.method)) {\n    if (opts.streamRequest) {\n      body = getRequestWebStream(event);\n      duplex = \"half\";\n    } else {\n      body = await readRawBody(event, false).catch(() => void 0);\n    }\n  }\n  const method = opts.fetchOptions?.method || event.method;\n  const fetchHeaders = mergeHeaders(\n    getProxyRequestHeaders(event),\n    opts.fetchOptions?.headers,\n    opts.headers\n  );\n  return sendProxy(event, target, {\n    ...opts,\n    fetchOptions: {\n      method,\n      body,\n      duplex,\n      ...opts.fetchOptions,\n      headers: fetchHeaders\n    }\n  });\n}\nasync function sendProxy(event, target, opts = {}) {\n  const response = await _getFetch(opts.fetch)(target, {\n    headers: opts.headers,\n    ignoreResponseError: true,\n    // make $ofetch.raw transparent\n    ...opts.fetchOptions\n  });\n  event.node.res.statusCode = sanitizeStatusCode(\n    response.status,\n    event.node.res.statusCode\n  );\n  event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\n  const cookies = [];\n  for (const [key, value] of response.headers.entries()) {\n    if (key === \"content-encoding\") {\n      continue;\n    }\n    if (key === \"content-length\") {\n      continue;\n    }\n    if (key === \"set-cookie\") {\n      cookies.push(...splitCookiesString(value));\n      continue;\n    }\n    event.node.res.setHeader(key, value);\n  }\n  if (cookies.length > 0) {\n    event.node.res.setHeader(\n      \"set-cookie\",\n      cookies.map((cookie) => {\n        if (opts.cookieDomainRewrite) {\n          cookie = rewriteCookieProperty(\n            cookie,\n            opts.cookieDomainRewrite,\n            \"domain\"\n          );\n        }\n        if (opts.cookiePathRewrite) {\n          cookie = rewriteCookieProperty(\n            cookie,\n            opts.cookiePathRewrite,\n            \"path\"\n          );\n        }\n        return cookie;\n      })\n    );\n  }\n  if (opts.onResponse) {\n    await opts.onResponse(event, response);\n  }\n  if (response._data !== void 0) {\n    return response._data;\n  }\n  if (event.handled) {\n    return;\n  }\n  if (opts.sendStream === false) {\n    const data = new Uint8Array(await response.arrayBuffer());\n    return event.node.res.end(data);\n  }\n  if (response.body) {\n    for await (const chunk of response.body) {\n      event.node.res.write(chunk);\n    }\n  }\n  return event.node.res.end();\n}\nfunction getProxyRequestHeaders(event) {\n  const headers = /* @__PURE__ */ Object.create(null);\n  const reqHeaders = getRequestHeaders(event);\n  for (const name in reqHeaders) {\n    if (!ignoredHeaders.has(name)) {\n      headers[name] = reqHeaders[name];\n    }\n  }\n  return headers;\n}\nfunction fetchWithEvent(event, req, init, options) {\n  return _getFetch(options?.fetch)(req, {\n    ...init,\n    context: init?.context || event.context,\n    headers: {\n      ...getProxyRequestHeaders(event),\n      ...init?.headers\n    }\n  });\n}\nfunction _getFetch(_fetch) {\n  if (_fetch) {\n    return _fetch;\n  }\n  if (globalThis.fetch) {\n    return globalThis.fetch;\n  }\n  throw new Error(\n    \"fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.\"\n  );\n}\nfunction rewriteCookieProperty(header, map, property) {\n  const _map = typeof map === \"string\" ? { \"*\": map } : map;\n  return header.replace(\n    new RegExp(`(;\\\\s*${property}=)([^;]+)`, \"gi\"),\n    (match, prefix, previousValue) => {\n      let newValue;\n      if (previousValue in _map) {\n        newValue = _map[previousValue];\n      } else if (\"*\" in _map) {\n        newValue = _map[\"*\"];\n      } else {\n        return match;\n      }\n      return newValue ? prefix + newValue : \"\";\n    }\n  );\n}\nfunction mergeHeaders(defaults, ...inputs) {\n  const _inputs = inputs.filter(Boolean);\n  if (_inputs.length === 0) {\n    return defaults;\n  }\n  const merged = new Headers(defaults);\n  for (const input of _inputs) {\n    for (const [key, value] of Object.entries(input)) {\n      if (value !== void 0) {\n        merged.set(key, value);\n      }\n    }\n  }\n  return merged;\n}\n\nconst DEFAULT_NAME = \"h3\";\nconst DEFAULT_COOKIE = {\n  path: \"/\",\n  secure: true,\n  httpOnly: true\n};\nasync function useSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  await getSession(event, config);\n  const sessionManager = {\n    get id() {\n      return event.context.sessions?.[sessionName]?.id;\n    },\n    get data() {\n      return event.context.sessions?.[sessionName]?.data || {};\n    },\n    update: async (update) => {\n      await updateSession(event, config, update);\n      return sessionManager;\n    },\n    clear: async () => {\n      await clearSession(event, config);\n      return sessionManager;\n    }\n  };\n  return sessionManager;\n}\nasync function getSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  if (!event.context.sessions) {\n    event.context.sessions = /* @__PURE__ */ Object.create(null);\n  }\n  if (event.context.sessions[sessionName]) {\n    return event.context.sessions[sessionName];\n  }\n  const session = {\n    id: \"\",\n    createdAt: 0,\n    data: /* @__PURE__ */ Object.create(null)\n  };\n  event.context.sessions[sessionName] = session;\n  let sealedSession;\n  if (config.sessionHeader !== false) {\n    const headerName = typeof config.sessionHeader === \"string\" ? config.sessionHeader.toLowerCase() : `x-${sessionName.toLowerCase()}-session`;\n    const headerValue = event.node.req.headers[headerName];\n    if (typeof headerValue === \"string\") {\n      sealedSession = headerValue;\n    }\n  }\n  if (!sealedSession) {\n    sealedSession = getCookie(event, sessionName);\n  }\n  if (sealedSession) {\n    const unsealed = await unsealSession(event, config, sealedSession).catch(\n      () => {\n      }\n    );\n    Object.assign(session, unsealed);\n  }\n  if (!session.id) {\n    session.id = config.generateId?.() ?? (config.crypto || crypto).randomUUID();\n    session.createdAt = Date.now();\n    await updateSession(event, config);\n  }\n  return session;\n}\nasync function updateSession(event, config, update) {\n  const sessionName = config.name || DEFAULT_NAME;\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\n  if (typeof update === \"function\") {\n    update = update(session.data);\n  }\n  if (update) {\n    Object.assign(session.data, update);\n  }\n  if (config.cookie !== false) {\n    const sealed = await sealSession(event, config);\n    setCookie(event, sessionName, sealed, {\n      ...DEFAULT_COOKIE,\n      expires: config.maxAge ? new Date(session.createdAt + config.maxAge * 1e3) : void 0,\n      ...config.cookie\n    });\n  }\n  return session;\n}\nasync function sealSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\n  const sealed = await seal(config.crypto || crypto, session, config.password, {\n    ...defaults,\n    ttl: config.maxAge ? config.maxAge * 1e3 : 0,\n    ...config.seal\n  });\n  return sealed;\n}\nasync function unsealSession(_event, config, sealed) {\n  const unsealed = await unseal(\n    config.crypto || crypto,\n    sealed,\n    config.password,\n    {\n      ...defaults,\n      ttl: config.maxAge ? config.maxAge * 1e3 : 0,\n      ...config.seal\n    }\n  );\n  if (config.maxAge) {\n    const age = Date.now() - (unsealed.createdAt || Number.NEGATIVE_INFINITY);\n    if (age > config.maxAge * 1e3) {\n      throw new Error(\"Session expired!\");\n    }\n  }\n  return unsealed;\n}\nasync function clearSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  if (event.context.sessions?.[sessionName]) {\n    delete event.context.sessions[sessionName];\n  }\n  await setCookie(event, sessionName, \"\", {\n    ...DEFAULT_COOKIE,\n    ...config.cookie\n  });\n}\n\nasync function serveStatic(event, options) {\n  if (event.method !== \"GET\" && event.method !== \"HEAD\") {\n    if (!options.fallthrough) {\n      throw createError({\n        statusMessage: \"Method Not Allowed\",\n        statusCode: 405\n      });\n    }\n    return false;\n  }\n  const originalId = decodePath(\n    withLeadingSlash(withoutTrailingSlash(parseURL(event.path).pathname))\n  );\n  const acceptEncodings = parseAcceptEncoding(\n    getRequestHeader(event, \"accept-encoding\"),\n    options.encodings\n  );\n  if (acceptEncodings.length > 1) {\n    setResponseHeader(event, \"vary\", \"accept-encoding\");\n  }\n  let id = originalId;\n  let meta;\n  const _ids = idSearchPaths(\n    originalId,\n    acceptEncodings,\n    options.indexNames || [\"/index.html\"]\n  );\n  for (const _id of _ids) {\n    const _meta = await options.getMeta(_id);\n    if (_meta) {\n      meta = _meta;\n      id = _id;\n      break;\n    }\n  }\n  if (!meta) {\n    if (!options.fallthrough) {\n      throw createError({\n        statusMessage: \"Cannot find static asset \" + id,\n        statusCode: 404\n      });\n    }\n    return false;\n  }\n  const ifNotMatch = meta.etag && getRequestHeader(event, \"if-none-match\") === meta.etag;\n  if (ifNotMatch) {\n    setResponseStatus(event, 304, \"Not Modified\");\n    return send(event, \"\");\n  }\n  if (meta.mtime) {\n    const mtimeDate = new Date(meta.mtime);\n    const ifModifiedSinceH = getRequestHeader(event, \"if-modified-since\");\n    if (ifModifiedSinceH && new Date(ifModifiedSinceH) >= mtimeDate) {\n      setResponseStatus(event, 304, \"Not Modified\");\n      return send(event, null);\n    }\n    if (!getResponseHeader(event, \"last-modified\")) {\n      setResponseHeader(event, \"last-modified\", mtimeDate.toUTCString());\n    }\n  }\n  if (meta.type && !getResponseHeader(event, \"content-type\")) {\n    setResponseHeader(event, \"content-type\", meta.type);\n  }\n  if (meta.etag && !getResponseHeader(event, \"etag\")) {\n    setResponseHeader(event, \"etag\", meta.etag);\n  }\n  if (meta.encoding && !getResponseHeader(event, \"content-encoding\")) {\n    setResponseHeader(event, \"content-encoding\", meta.encoding);\n  }\n  if (meta.size !== void 0 && meta.size > 0 && !getResponseHeader(event, \"content-length\")) {\n    setResponseHeader(event, \"content-length\", meta.size);\n  }\n  if (event.method === \"HEAD\") {\n    return send(event, null);\n  }\n  const contents = await options.getContents(id);\n  return isStream(contents) ? sendStream(event, contents) : send(event, contents);\n}\nfunction parseAcceptEncoding(header, encodingMap) {\n  if (!encodingMap || !header) {\n    return [];\n  }\n  return String(header || \"\").split(\",\").map((e) => encodingMap[e.trim()]).filter(Boolean);\n}\nfunction idSearchPaths(id, encodings, indexNames) {\n  const ids = [];\n  for (const suffix of [\"\", ...indexNames]) {\n    for (const encoding of [...encodings, \"\"]) {\n      ids.push(`${id}${suffix}${encoding}`);\n    }\n  }\n  return ids;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass H3Event {\n  constructor(req, res) {\n    __publicField(this, \"__is_event__\", true);\n    // Context\n    __publicField(this, \"node\");\n    // Node\n    __publicField(this, \"web\");\n    // Web\n    __publicField(this, \"context\", {});\n    // Shared\n    // Request\n    __publicField(this, \"_method\");\n    __publicField(this, \"_path\");\n    __publicField(this, \"_headers\");\n    __publicField(this, \"_requestBody\");\n    // Response\n    __publicField(this, \"_handled\", false);\n    this.node = { req, res };\n  }\n  // --- Request ---\n  get method() {\n    if (!this._method) {\n      this._method = (this.node.req.method || \"GET\").toUpperCase();\n    }\n    return this._method;\n  }\n  get path() {\n    return this._path || this.node.req.url || \"/\";\n  }\n  get headers() {\n    if (!this._headers) {\n      this._headers = _normalizeNodeHeaders(this.node.req.headers);\n    }\n    return this._headers;\n  }\n  // --- Respoonse ---\n  get handled() {\n    return this._handled || this.node.res.writableEnded || this.node.res.headersSent;\n  }\n  respondWith(response) {\n    return Promise.resolve(response).then(\n      (_response) => sendWebResponse(this, _response)\n    );\n  }\n  // --- Utils ---\n  toString() {\n    return `[${this.method}] ${this.path}`;\n  }\n  toJSON() {\n    return this.toString();\n  }\n  // --- Deprecated ---\n  /** @deprecated Please use `event.node.req` instead. **/\n  get req() {\n    return this.node.req;\n  }\n  /** @deprecated Please use `event.node.res` instead. **/\n  get res() {\n    return this.node.res;\n  }\n}\nfunction isEvent(input) {\n  return hasProp(input, \"__is_event__\");\n}\nfunction createEvent(req, res) {\n  return new H3Event(req, res);\n}\nfunction _normalizeNodeHeaders(nodeHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of Object.entries(nodeHeaders)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        headers.append(name, item);\n      }\n    } else if (value) {\n      headers.set(name, value);\n    }\n  }\n  return headers;\n}\n\nfunction defineEventHandler(handler) {\n  if (typeof handler === \"function\") {\n    return Object.assign(handler, { __is_handler__: true });\n  }\n  const _hooks = {\n    onRequest: _normalizeArray(handler.onRequest),\n    onBeforeResponse: _normalizeArray(handler.onBeforeResponse)\n  };\n  const _handler = (event) => {\n    return _callHandler(event, handler.handler, _hooks);\n  };\n  return Object.assign(_handler, { __is_handler__: true });\n}\nfunction _normalizeArray(input) {\n  return input ? Array.isArray(input) ? input : [input] : void 0;\n}\nasync function _callHandler(event, handler, hooks) {\n  if (hooks.onRequest) {\n    for (const hook of hooks.onRequest) {\n      await hook(event);\n      if (event.handled) {\n        return;\n      }\n    }\n  }\n  const body = await handler(event);\n  const response = { body };\n  if (hooks.onBeforeResponse) {\n    for (const hook of hooks.onBeforeResponse) {\n      await hook(event, response);\n    }\n  }\n  return response.body;\n}\nconst eventHandler = defineEventHandler;\nfunction defineRequestMiddleware(fn) {\n  return fn;\n}\nfunction defineResponseMiddleware(fn) {\n  return fn;\n}\nfunction isEventHandler(input) {\n  return hasProp(input, \"__is_handler__\");\n}\nfunction toEventHandler(input, _, _route) {\n  if (!isEventHandler(input)) {\n    console.warn(\n      \"[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.\",\n      _route && _route !== \"/\" ? `\n     Route: ${_route}` : \"\",\n      `\n     Handler: ${input}`\n    );\n  }\n  return input;\n}\nfunction dynamicEventHandler(initial) {\n  let current = initial;\n  const wrapper = eventHandler((event) => {\n    if (current) {\n      return current(event);\n    }\n  });\n  wrapper.set = (handler) => {\n    current = handler;\n  };\n  return wrapper;\n}\nfunction defineLazyEventHandler(factory) {\n  let _promise;\n  let _resolved;\n  const resolveHandler = () => {\n    if (_resolved) {\n      return Promise.resolve(_resolved);\n    }\n    if (!_promise) {\n      _promise = Promise.resolve(factory()).then((r) => {\n        const handler = r.default || r;\n        if (typeof handler !== \"function\") {\n          throw new TypeError(\n            \"Invalid lazy handler result. It should be a function:\",\n            handler\n          );\n        }\n        _resolved = toEventHandler(r.default || r);\n        return _resolved;\n      });\n    }\n    return _promise;\n  };\n  return eventHandler((event) => {\n    if (_resolved) {\n      return _resolved(event);\n    }\n    return resolveHandler().then((handler) => handler(event));\n  });\n}\nconst lazyEventHandler = defineLazyEventHandler;\n\nconst H3Headers = globalThis.Headers;\nconst H3Response = globalThis.Response;\n\nfunction createApp(options = {}) {\n  const stack = [];\n  const handler = createAppEventHandler(stack, options);\n  const app = {\n    // @ts-ignore\n    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),\n    handler,\n    stack,\n    options\n  };\n  return app;\n}\nfunction use(app, arg1, arg2, arg3) {\n  if (Array.isArray(arg1)) {\n    for (const i of arg1) {\n      use(app, i, arg2, arg3);\n    }\n  } else if (Array.isArray(arg2)) {\n    for (const i of arg2) {\n      use(app, arg1, i, arg3);\n    }\n  } else if (typeof arg1 === \"string\") {\n    app.stack.push(\n      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })\n    );\n  } else if (typeof arg1 === \"function\") {\n    app.stack.push(\n      normalizeLayer({ ...arg2, route: \"/\", handler: arg1 })\n    );\n  } else {\n    app.stack.push(normalizeLayer({ ...arg1 }));\n  }\n  return app;\n}\nfunction createAppEventHandler(stack, options) {\n  const spacing = options.debug ? 2 : void 0;\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const _reqPath = event._path || event.node.req.url || \"/\";\n    let _layerPath;\n    if (options.onRequest) {\n      await options.onRequest(event);\n    }\n    for (const layer of stack) {\n      if (layer.route.length > 1) {\n        if (!_reqPath.startsWith(layer.route)) {\n          continue;\n        }\n        _layerPath = _reqPath.slice(layer.route.length) || \"/\";\n      } else {\n        _layerPath = _reqPath;\n      }\n      if (layer.match && !layer.match(_layerPath, event)) {\n        continue;\n      }\n      event._path = _layerPath;\n      event.node.req.url = _layerPath;\n      const val = await layer.handler(event);\n      const _body = val === void 0 ? void 0 : await val;\n      if (_body !== void 0) {\n        const _response = { body: _body };\n        if (options.onBeforeResponse) {\n          await options.onBeforeResponse(event, _response);\n        }\n        await handleHandlerResponse(event, _response.body, spacing);\n        if (options.onAfterResponse) {\n          await options.onAfterResponse(event, _response);\n        }\n        return;\n      }\n      if (event.handled) {\n        if (options.onAfterResponse) {\n          await options.onAfterResponse(event, void 0);\n        }\n        return;\n      }\n    }\n    if (!event.handled) {\n      throw createError({\n        statusCode: 404,\n        statusMessage: `Cannot find any path matching ${event.path || \"/\"}.`\n      });\n    }\n    if (options.onAfterResponse) {\n      await options.onAfterResponse(event, void 0);\n    }\n  });\n}\nfunction normalizeLayer(input) {\n  let handler = input.handler;\n  if (handler.handler) {\n    handler = handler.handler;\n  }\n  if (input.lazy) {\n    handler = lazyEventHandler(handler);\n  } else if (!isEventHandler(handler)) {\n    handler = toEventHandler(handler, void 0, input.route);\n  }\n  return {\n    route: withoutTrailingSlash(input.route),\n    match: input.match,\n    handler\n  };\n}\nfunction handleHandlerResponse(event, val, jsonSpace) {\n  if (val === null) {\n    return sendNoContent(event);\n  }\n  if (val) {\n    if (isWebResponse(val)) {\n      return sendWebResponse(event, val);\n    }\n    if (isStream(val)) {\n      return sendStream(event, val);\n    }\n    if (val.buffer) {\n      return send(event, val);\n    }\n    if (val.arrayBuffer && typeof val.arrayBuffer === \"function\") {\n      return val.arrayBuffer().then((arrayBuffer) => {\n        return send(event, Buffer.from(arrayBuffer), val.type);\n      });\n    }\n    if (val instanceof Error) {\n      throw createError(val);\n    }\n    if (typeof val.end === \"function\") {\n      return true;\n    }\n  }\n  const valType = typeof val;\n  if (valType === \"string\") {\n    return send(event, val, MIMES.html);\n  }\n  if (valType === \"object\" || valType === \"boolean\" || valType === \"number\") {\n    return send(event, JSON.stringify(val, void 0, jsonSpace), MIMES.json);\n  }\n  if (valType === \"bigint\") {\n    return send(event, val.toString(), MIMES.json);\n  }\n  throw createError({\n    statusCode: 500,\n    statusMessage: `[h3] Cannot send ${valType} as response.`\n  });\n}\n\nconst RouterMethods = [\n  \"connect\",\n  \"delete\",\n  \"get\",\n  \"head\",\n  \"options\",\n  \"post\",\n  \"put\",\n  \"trace\",\n  \"patch\"\n];\nfunction createRouter(opts = {}) {\n  const _router = createRouter$1({});\n  const routes = {};\n  let _matcher;\n  const router = {};\n  const addRoute = (path, handler, method) => {\n    let route = routes[path];\n    if (!route) {\n      routes[path] = route = { path, handlers: {} };\n      _router.insert(path, route);\n    }\n    if (Array.isArray(method)) {\n      for (const m of method) {\n        addRoute(path, handler, m);\n      }\n    } else {\n      route.handlers[method] = toEventHandler(handler, void 0, path);\n    }\n    return router;\n  };\n  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || \"all\");\n  for (const method of RouterMethods) {\n    router[method] = (path, handle) => router.add(path, handle, method);\n  }\n  router.handler = eventHandler((event) => {\n    let path = event.path || \"/\";\n    const qIndex = path.indexOf(\"?\");\n    if (qIndex !== -1) {\n      path = path.slice(0, Math.max(0, qIndex));\n    }\n    const matched = _router.lookup(path);\n    if (!matched || !matched.handlers) {\n      if (opts.preemptive || opts.preemtive) {\n        throw createError({\n          statusCode: 404,\n          name: \"Not Found\",\n          statusMessage: `Cannot find any route matching ${event.path || \"/\"}.`\n        });\n      } else {\n        return;\n      }\n    }\n    const method = (event.node.req.method || \"get\").toLowerCase();\n    let handler = matched.handlers[method] || matched.handlers.all;\n    if (!handler) {\n      if (!_matcher) {\n        _matcher = toRouteMatcher(_router);\n      }\n      const _matches = _matcher.matchAll(path).reverse();\n      for (const _match of _matches) {\n        if (_match.handlers[method]) {\n          handler = _match.handlers[method];\n          matched.handlers[method] = matched.handlers[method] || handler;\n          break;\n        }\n        if (_match.handlers.all) {\n          handler = _match.handlers.all;\n          matched.handlers.all = matched.handlers.all || handler;\n          break;\n        }\n      }\n    }\n    if (!handler) {\n      if (opts.preemptive || opts.preemtive) {\n        throw createError({\n          statusCode: 405,\n          name: \"Method Not Allowed\",\n          statusMessage: `Method ${method} is not allowed on this route.`\n        });\n      } else {\n        return;\n      }\n    }\n    event.context.matchedRoute = matched;\n    const params = matched.params || {};\n    event.context.params = params;\n    return Promise.resolve(handler(event)).then((res) => {\n      if (res === void 0 && (opts.preemptive || opts.preemtive)) {\n        return null;\n      }\n      return res;\n    });\n  });\n  return router;\n}\n\nconst defineNodeListener = (handler) => handler;\nconst defineNodeMiddleware = (middleware) => middleware;\nfunction fromNodeMiddleware(handler) {\n  if (isEventHandler(handler)) {\n    return handler;\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\n      \"Invalid handler. It should be a function:\",\n      handler\n    );\n  }\n  return eventHandler((event) => {\n    return callNodeListener(\n      handler,\n      event.node.req,\n      event.node.res\n    );\n  });\n}\nfunction toNodeListener(app) {\n  const toNodeHandle = async function(req, res) {\n    const event = createEvent(req, res);\n    try {\n      await app.handler(event);\n    } catch (_error) {\n      const error = createError(_error);\n      if (!isError(_error)) {\n        error.unhandled = true;\n      }\n      if (app.options.onError) {\n        await app.options.onError(error, event);\n      }\n      if (event.handled) {\n        return;\n      }\n      if (error.unhandled || error.fatal) {\n        console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n      }\n      await sendError(event, error, !!app.options.debug);\n    }\n  };\n  return toNodeHandle;\n}\nfunction promisifyNodeListener(handler) {\n  return function(req, res) {\n    return callNodeListener(handler, req, res);\n  };\n}\nfunction callNodeListener(handler, req, res) {\n  const isMiddleware = handler.length > 2;\n  return new Promise((resolve, reject) => {\n    const next = (err) => {\n      if (isMiddleware) {\n        res.off(\"close\", next);\n        res.off(\"error\", next);\n      }\n      return err ? reject(createError(err)) : resolve(void 0);\n    };\n    try {\n      const returned = handler(req, res, next);\n      if (isMiddleware && returned === void 0) {\n        res.once(\"close\", next);\n        res.once(\"error\", next);\n      } else {\n        resolve(returned);\n      }\n    } catch (error) {\n      next(error);\n    }\n  });\n}\n\nfunction toPlainHandler(app) {\n  const handler = (request) => {\n    return _handlePlainRequest(app, request);\n  };\n  return handler;\n}\nfunction fromPlainHandler(handler) {\n  return eventHandler(async (event) => {\n    const res = await handler({\n      method: event.method,\n      path: event.path,\n      headers: Object.fromEntries(event.headers.entries()),\n      body: getRequestWebStream(event),\n      context: event.context\n    });\n    setResponseStatus(event, res.status, res.statusText);\n    for (const [key, value] of res.headers) {\n      setResponseHeader(event, key, value);\n    }\n    return res.body;\n  });\n}\nasync function _handlePlainRequest(app, request) {\n  const path = request.path;\n  const method = (request.method || \"GET\").toUpperCase();\n  const headers = new Headers(request.headers);\n  const nodeReq = new IncomingMessage();\n  const nodeRes = new ServerResponse(nodeReq);\n  nodeReq.method = method;\n  nodeReq.url = path;\n  nodeReq.headers = Object.fromEntries(headers.entries());\n  const event = createEvent(nodeReq, nodeRes);\n  event._method = method;\n  event._path = path;\n  event._headers = headers;\n  if (request.body) {\n    event._requestBody = request.body;\n  }\n  if (request._eventOverrides) {\n    Object.assign(event, request._eventOverrides);\n  }\n  if (request.context) {\n    Object.assign(event.context, request.context);\n  }\n  try {\n    await app.handler(event);\n  } catch (_error) {\n    const error = createError(_error);\n    if (!isError(_error)) {\n      error.unhandled = true;\n    }\n    if (app.options.onError) {\n      await app.options.onError(error, event);\n    }\n    if (!event.handled) {\n      if (error.unhandled || error.fatal) {\n        console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n      }\n      await sendError(event, error, !!app.options.debug);\n    }\n  }\n  return {\n    status: nodeRes.statusCode,\n    statusText: nodeRes.statusMessage,\n    headers: _normalizeUnenvHeaders(nodeRes._headers),\n    body: nodeRes._data\n  };\n}\nfunction _normalizeUnenvHeaders(input) {\n  const headers = [];\n  const cookies = [];\n  for (const _key in input) {\n    const key = _key.toLowerCase();\n    if (key === \"set-cookie\") {\n      cookies.push(\n        ...splitCookiesString(input[\"set-cookie\"])\n      );\n      continue;\n    }\n    const value = input[key];\n    if (Array.isArray(value)) {\n      for (const _value of value) {\n        headers.push([key, _value]);\n      }\n    } else if (value !== void 0) {\n      headers.push([key, String(value)]);\n    }\n  }\n  if (cookies.length > 0) {\n    for (const cookie of cookies) {\n      headers.push([\"set-cookie\", cookie]);\n    }\n  }\n  return headers;\n}\n\nfunction toWebHandler(app) {\n  const webHandler = (request, context) => {\n    return _handleWebRequest(app, request, context);\n  };\n  return webHandler;\n}\nfunction fromWebHandler(handler) {\n  return eventHandler((event) => handler(toWebRequest(event), event.context));\n}\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nasync function _handleWebRequest(app, request, context) {\n  const url = new URL(request.url);\n  const res = await _handlePlainRequest(app, {\n    _eventOverrides: {\n      web: { request, url }\n    },\n    context,\n    method: request.method,\n    path: url.pathname + url.search,\n    headers: request.headers,\n    body: request.body\n  });\n  const body = nullBodyResponses.has(res.status) || request.method === \"HEAD\" ? null : res.body;\n  return new Response(body, {\n    status: res.status,\n    statusText: res.statusText,\n    headers: res.headers\n  });\n}\n\nexport { H3Error, H3Event, H3Headers, H3Response, MIMES, appendCorsHeaders, appendCorsPreflightHeaders, appendHeader, appendHeaders, appendResponseHeader, appendResponseHeaders, assertMethod, callNodeListener, clearResponseHeaders, clearSession, createApp, createAppEventHandler, createError, createEvent, createRouter, defaultContentType, defineEventHandler, defineLazyEventHandler, defineNodeListener, defineNodeMiddleware, defineRequestMiddleware, defineResponseMiddleware, deleteCookie, dynamicEventHandler, eventHandler, fetchWithEvent, fromNodeMiddleware, fromPlainHandler, fromWebHandler, getCookie, getHeader, getHeaders, getMethod, getProxyRequestHeaders, getQuery, getRequestHeader, getRequestHeaders, getRequestHost, getRequestIP, getRequestPath, getRequestProtocol, getRequestURL, getRequestWebStream, getResponseHeader, getResponseHeaders, getResponseStatus, getResponseStatusText, getRouterParam, getRouterParams, getSession, getValidatedQuery, handleCacheHeaders, handleCors, isCorsOriginAllowed, isError, isEvent, isEventHandler, isMethod, isPreflightRequest, isStream, isWebResponse, lazyEventHandler, parseCookies, promisifyNodeListener, proxyRequest, readBody, readFormData, readMultipartFormData, readRawBody, readValidatedBody, removeResponseHeader, sanitizeStatusCode, sanitizeStatusMessage, sealSession, send, sendError, sendNoContent, sendProxy, sendRedirect, sendStream, sendWebResponse, serveStatic, setCookie, setHeader, setHeaders, setResponseHeader, setResponseHeaders, setResponseStatus, splitCookiesString, toEventHandler, toNodeListener, toPlainHandler, toWebHandler, toWebRequest, unsealSession, updateSession, use, useBase, useSession, writeEarlyHints };\n","{\n  \"name\": \"uploadthing\",\n  \"version\": \"6.0.0\",\n  \"engines\": {\n    \"node\": \">=18.13.0\"\n  },\n  \"license\": \"MIT\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \"./client\": {\n      \"types\": \"./dist/client.d.ts\",\n      \"import\": \"./dist/client.mjs\",\n      \"require\": \"./dist/client.js\"\n    },\n    \"./server\": {\n      \"types\": \"./dist/server.d.ts\",\n      \"import\": \"./dist/server.mjs\",\n      \"require\": \"./dist/server.js\"\n    },\n    \"./next\": {\n      \"types\": \"./dist/next.d.ts\",\n      \"import\": \"./dist/next.mjs\",\n      \"require\": \"./dist/next.js\"\n    },\n    \"./next-legacy\": {\n      \"types\": \"./dist/next-legacy.d.ts\",\n      \"import\": \"./dist/next-legacy.mjs\",\n      \"require\": \"./dist/next-legacy.js\"\n    },\n    \"./express\": {\n      \"import\": \"./dist/express.mjs\",\n      \"types\": \"./dist/express.d.ts\",\n      \"require\": \"./dist/express.js\"\n    },\n    \"./tw\": {\n      \"types\": \"./dist/tw.d.ts\",\n      \"import\": \"./dist/tw.mjs\",\n      \"require\": \"./dist/tw.js\"\n    },\n    \"./fastify\": {\n      \"types\": \"./dist/fastify.d.ts\",\n      \"import\": \"./dist/fastify.mjs\",\n      \"require\": \"./dist/fastify.js\"\n    },\n    \"./h3\": {\n      \"types\": \"./dist/h3.d.ts\",\n      \"import\": \"./dist/h3.mjs\",\n      \"require\": \"./dist/h3.js\"\n    }\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"client\": [\n        \"dist/client.d.ts\"\n      ],\n      \"server\": [\n        \"dist/server.d.ts\"\n      ],\n      \"next\": [\n        \"dist/next.d.ts\"\n      ],\n      \"next-legacy\": [\n        \"dist/next-legacy.d.ts\"\n      ],\n      \"tw\": [\n        \"dist/tw.d.ts\"\n      ],\n      \"express\": [\n        \"dist/express.d.ts\"\n      ],\n      \"fastify\": [\n        \"dist/fastify.d.ts\"\n      ],\n      \"h3\": [\n        \"dist/h3.d.ts\"\n      ]\n    }\n  },\n  \"scripts\": {\n    \"lint\": \"eslint \\\"**/*.{ts,tsx}\\\" --max-warnings 0\",\n    \"build\": \"tsup\",\n    \"clean\": \"git clean -xdf dist node_modules\",\n    \"dev\": \"tsup --watch\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@uploadthing/mime-types\": \"^0.2.2\",\n    \"@uploadthing/shared\": \"^6.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/express\": \"^4.17.17\",\n    \"@types/react\": \"18.2.33\",\n    \"@uploadthing/eslint-config\": \"0.2.0\",\n    \"@uploadthing/tsconfig\": \"0.1.0\",\n    \"@uploadthing/tsup-config\": \"0.1.0\",\n    \"eslint\": \"^8.47.0\",\n    \"express\": \"^4.18.2\",\n    \"fastify\": \"^4.23.2\",\n    \"h3\": \"^1.8.1\",\n    \"next\": \"14.0.1\",\n    \"solid-js\": \"^1.7.11\",\n    \"tailwindcss\": \"^3.3.2\",\n    \"tsup\": \"6.7.0\",\n    \"type-fest\": \"^3.11.1\",\n    \"typescript\": \"^5.1.6\",\n    \"undici\": \"^5.20.0\",\n    \"vitest\": \"^0.30.1\",\n    \"zod\": \"^3.22.3\"\n  },\n  \"eslintConfig\": {\n    \"root\": true,\n    \"extends\": [\n      \"@uploadthing/eslint-config/base\"\n    ]\n  }\n}\n","import packageJson from \"../package.json\";\n\nif (!packageJson.version) throw new Error(\"no version found in package.json\");\nexport const UPLOADTHING_VERSION = packageJson.version;\n","import type { UploadThingError } from \"@uploadthing/shared\";\n\nimport type { FileRouter, inferErrorShape } from \"./types\";\n\nexport function defaultErrorFormatter(error: UploadThingError) {\n  return {\n    message: error.message,\n  };\n}\n\nexport function formatError<TRouter extends FileRouter>(\n  error: UploadThingError,\n  router: TRouter,\n): inferErrorShape<TRouter> {\n  const errorFormatter =\n    router[Object.keys(router)[0]]?._def.errorFormatter ??\n    defaultErrorFormatter;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return errorFormatter(error);\n}\n","import type EventEmitter from \"events\";\n\nimport type { MimeType } from \"@uploadthing/mime-types/db\";\nimport {\n  generateUploadThingURL,\n  getTypeFromFileName,\n  isObject,\n  objectKeys,\n  fillInputRouteConfig as parseAndExpandInputConfig,\n  safeParseJSON,\n  UploadThingError,\n} from \"@uploadthing/shared\";\nimport type {\n  ContentDisposition,\n  ExpandedRouteConfig,\n  FileRouterInputKey,\n  Json,\n  RequestLike,\n  UploadedFile,\n} from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\nimport { conditionalDevServer } from \"./dev-hook\";\nimport { getParseFn } from \"./parser\";\nimport { VALID_ACTION_TYPES } from \"./types\";\nimport type { ActionType, FileRouter, UTEvents } from \"./types\";\n\n/**\n * Creates a wrapped fetch that will always forward a few headers to the server.\n */\nconst createUTFetch = (apiKey: string) => {\n  return async (endpoint: `/${string}`, payload: unknown) => {\n    const response = await fetch(generateUploadThingURL(endpoint), {\n      method: \"POST\",\n      body: JSON.stringify(payload),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-uploadthing-api-key\": apiKey,\n        \"x-uploadthing-version\": UPLOADTHING_VERSION,\n      },\n    });\n\n    return response;\n  };\n};\n\nconst fileCountLimitHit = (\n  files: { name: string }[],\n  routeConfig: ExpandedRouteConfig,\n) => {\n  const counts: Record<string, number> = {};\n\n  files.forEach((file) => {\n    const type = getTypeFromFileName(file.name, objectKeys(routeConfig));\n\n    if (!counts[type]) {\n      counts[type] = 1;\n    } else {\n      counts[type] += 1;\n    }\n  });\n\n  for (const _key in counts) {\n    const key = _key as FileRouterInputKey;\n    const count = counts[key];\n    const limit = routeConfig[key]?.maxFileCount;\n\n    if (!limit) {\n      console.error(routeConfig, key);\n      throw new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid config during file count\",\n        cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`,\n      });\n    }\n\n    if (count > limit) {\n      return { limitHit: true, type: key, limit, count };\n    }\n  }\n\n  return { limitHit: false };\n};\n\nexport type RouterWithConfig<TRouter extends FileRouter> = {\n  router: TRouter;\n  config?: {\n    /**\n     * @deprecated since v6.0.0\n     * this option is deprecated and will be removed in a future version, you can safely remove it from your config\n     */\n    callbackUrl?: string;\n    uploadthingId?: string;\n    uploadthingSecret?: string;\n  };\n};\n\nconst getHeader = (req: RequestLike, key: string) => {\n  if (req.headers instanceof Headers) {\n    return req.headers.get(key);\n  }\n  return req.headers[key];\n};\n\nexport type UploadThingResponse = {\n  presignedUrls: string[];\n  key: string;\n  pollingUrl: string;\n  uploadId: string;\n  fileName: string;\n  fileType: MimeType;\n  contentDisposition: ContentDisposition;\n  chunkCount: number;\n  chunkSize: number;\n}[];\n\nexport const buildRequestHandler = <TRouter extends FileRouter>(\n  opts: RouterWithConfig<TRouter>,\n  ee?: EventEmitter,\n) => {\n  return async (input: {\n    req: RequestLike;\n    // Allow for overriding request URL since some req.url are read-only\n    // If the adapter doesn't give a full url on `req.url`, this should be set\n    url?: URL;\n    res?: unknown;\n    event?: unknown;\n  }): Promise<\n    UploadThingError | { status: 200; body?: UploadThingResponse }\n  > => {\n    if (process.env.NODE_ENV === \"development\") {\n      console.log(\"[UT] UploadThing dev server is now running!\");\n    }\n\n    const { req, res, event } = input;\n    const { router, config } = opts;\n    const preferredOrEnvSecret =\n      config?.uploadthingSecret ?? process.env.UPLOADTHING_SECRET;\n\n    let url: URL;\n    try {\n      url = new URL(input.url ?? req.url ?? \"\");\n    } catch (error) {\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: `Invalid url '${input.url?.href ?? req.url}'`,\n        cause: error,\n      });\n    }\n\n    // Get inputs from query and params\n    const params = url.searchParams;\n    const uploadthingHook = getHeader(req, \"uploadthing-hook\") ?? undefined;\n    const slug = params.get(\"slug\") ?? undefined;\n    const actionType = (params.get(\"actionType\") as ActionType) ?? undefined;\n\n    // Validate inputs\n    if (!slug)\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"No slug provided\",\n      });\n\n    if (slug && typeof slug !== \"string\") {\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"`slug` must be a string\",\n        cause: `Expected slug to be of type 'string', got '${typeof slug}'`,\n      });\n    }\n    if (actionType && typeof actionType !== \"string\") {\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"`actionType` must be a string\",\n        cause: `Expected actionType to be of type 'string', got '${typeof actionType}'`,\n      });\n    }\n    if (uploadthingHook && typeof uploadthingHook !== \"string\") {\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"`uploadthingHook` must be a string\",\n        cause: `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`,\n      });\n    }\n\n    if (!preferredOrEnvSecret) {\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: `Please set your preferred secret in ${slug} router's config or set UPLOADTHING_SECRET in your env file`,\n        cause: \"No secret provided\",\n      });\n    }\n\n    const uploadable = router[slug];\n    if (!uploadable) {\n      return new UploadThingError({\n        code: \"NOT_FOUND\",\n        message: `No file route found for slug ${slug}`,\n      });\n    }\n\n    if (uploadthingHook === \"callback\") {\n      // This is when we receive the webhook from uploadthing\n      const maybeReqBody = await safeParseJSON<{\n        file: UploadedFile;\n        files: unknown;\n        metadata: Record<string, unknown>;\n        input?: Json;\n      }>(req);\n\n      if (maybeReqBody instanceof Error) {\n        return new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid request body\",\n          cause: maybeReqBody,\n        });\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const res = await uploadable.resolver({\n        file: maybeReqBody.file,\n        metadata: maybeReqBody.metadata,\n      });\n      ee?.emit(\"callbackDone\", res);\n\n      return { status: 200 };\n    }\n\n    if (!actionType || !VALID_ACTION_TYPES.includes(actionType)) {\n      // This would either be someone spamming or the AWS webhook\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        cause: `Invalid action type ${actionType}`,\n        message: `Expected ${VALID_ACTION_TYPES.map((x) => `\"${x}\"`)\n          .join(\", \")\n          .replace(/,(?!.*,)/, \" or\")} but got \"${\"a\"}\"`,\n      });\n    }\n\n    const utFetch = createUTFetch(preferredOrEnvSecret);\n\n    switch (actionType) {\n      case \"upload\": {\n        const maybeInput = await safeParseJSON<UTEvents[\"upload\"]>(req);\n\n        if (maybeInput instanceof Error) {\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid request body\",\n            cause: maybeInput,\n          });\n        }\n        const { files, input: userInput } = maybeInput;\n\n        // validate the input\n        let parsedInput: Json = {};\n        try {\n          const inputParser = uploadable._def.inputParser;\n          parsedInput = await getParseFn(inputParser)(userInput);\n        } catch (error) {\n          console.error(error);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid input.\",\n            cause: error,\n          });\n        }\n\n        let metadata: Json = {};\n        try {\n          metadata = await uploadable._def.middleware({\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            req: req as any,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            res: res as any,\n            event,\n            input: parsedInput,\n          });\n        } catch (error) {\n          console.error(error);\n          return new UploadThingError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to run middleware.\",\n            cause: error,\n          });\n        }\n\n        // Validate without Zod (for now)\n        if (\n          !Array.isArray(files) ||\n          !files.every(\n            (f) =>\n              isObject(f) &&\n              typeof f.name === \"string\" &&\n              typeof f.size === \"number\",\n          )\n        )\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Files must be an array of objects with name and size\",\n            cause: `Expected files to be of type '{name:string, size:number}[]', got '${JSON.stringify(\n              files,\n            )}'`,\n          });\n\n        // FILL THE ROUTE CONFIG so the server only has one happy path\n        let parsedConfig: ReturnType<typeof parseAndExpandInputConfig>;\n        try {\n          parsedConfig = parseAndExpandInputConfig(\n            uploadable._def.routerConfig,\n          );\n        } catch (error) {\n          console.error(error);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid config.\",\n            cause: error,\n          });\n        }\n\n        try {\n          const { limitHit, count, limit, type } = fileCountLimitHit(\n            files,\n            parsedConfig,\n          );\n          if (limitHit) {\n            return new UploadThingError({\n              code: \"BAD_REQUEST\",\n              message: \"File limit exceeded\",\n              cause: `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`,\n            });\n          }\n        } catch (error) {\n          console.error(error);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid config.\",\n            cause: error,\n          });\n        }\n\n        const callbackUrl = url.origin + url.pathname;\n\n        const uploadthingApiResponse = await utFetch(\"/api/prepareUpload\", {\n          files: files,\n\n          routeConfig: parsedConfig,\n\n          metadata,\n          callbackUrl: config?.callbackUrl ?? callbackUrl,\n          callbackSlug: slug,\n        });\n\n        // This is when we send the response back to the user's form so they can submit the files\n        const parsedResponse = await safeParseJSON<UploadThingResponse>(\n          uploadthingApiResponse,\n        );\n\n        if (!uploadthingApiResponse.ok || parsedResponse instanceof Error) {\n          console.error(\"[UT] unable to get presigned urls\");\n          return new UploadThingError({\n            code: \"URL_GENERATION_FAILED\",\n            message: \"Unable to get presigned urls\",\n            cause: parsedResponse,\n          });\n        }\n\n        // This is when we send the response back to the user's form so they can submit the files\n\n        if (process.env.NODE_ENV === \"development\") {\n          for (const file of parsedResponse) {\n            void conditionalDevServer({\n              fileKey: file.key,\n              apiKey: preferredOrEnvSecret,\n            });\n          }\n        }\n\n        return {\n          body: parsedResponse.map((x) => ({\n            ...x,\n            pollingUrl: generateUploadThingURL(`/api/pollUpload/${x.key}`),\n          })),\n          status: 200,\n        };\n      }\n      case \"multipart-complete\": {\n        const maybeReqBody = await safeParseJSON<\n          UTEvents[\"multipart-complete\"]\n        >(req);\n        if (maybeReqBody instanceof Error) {\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid request body\",\n            cause: maybeReqBody,\n          });\n        }\n\n        const completeRes = await utFetch(\"/api/completeMultipart\", {\n          fileKey: maybeReqBody.fileKey,\n          uploadId: maybeReqBody.uploadId,\n          etags: maybeReqBody.etags,\n        });\n        if (!completeRes.ok) {\n          return new UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to complete multipart upload\",\n          });\n        }\n\n        return { status: 200 };\n      }\n      case \"failure\": {\n        const maybeReqBody = await safeParseJSON<UTEvents[\"failure\"]>(req);\n        if (maybeReqBody instanceof Error) {\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid request body\",\n            cause: maybeReqBody,\n          });\n        }\n        const { fileKey, uploadId } = maybeReqBody;\n\n        // Tell uploadthing to mark the upload as failed\n        const uploadthingApiResponse = await utFetch(\"/api/failureCallback\", {\n          fileKey,\n          uploadId,\n        });\n\n        if (!uploadthingApiResponse.ok) {\n          console.error(\"[UT] failed to mark upload as failed\");\n          const parsedResponse = await safeParseJSON<UploadThingResponse>(\n            uploadthingApiResponse,\n          );\n          return new UploadThingError({\n            code: \"URL_GENERATION_FAILED\",\n            message: \"Unable to get presigned urls\",\n            cause: parsedResponse,\n          });\n        }\n\n        try {\n          // Run the onUploadError callback\n          uploadable._def.onUploadError({\n            error: new UploadThingError({\n              code: \"UPLOAD_FAILED\",\n              message: `Upload failed for ${fileKey}`,\n            }),\n            fileKey,\n          });\n        } catch (error) {\n          console.error(\n            \"[UT] Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback.\",\n          );\n          console.error(error);\n\n          return new UploadThingError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"Failed to run onUploadError callback\",\n            cause: error,\n          });\n        }\n\n        return { status: 200 };\n      }\n      default: {\n        // This should never happen\n        return new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message: `Invalid action type`,\n        });\n      }\n    }\n  };\n};\n\nexport const buildPermissionsInfoHandler = <TRouter extends FileRouter>(\n  opts: RouterWithConfig<TRouter>,\n) => {\n  return () => {\n    const r = opts.router;\n\n    const permissions = Object.keys(r).map((k) => {\n      const route = r[k];\n      const config = parseAndExpandInputConfig(route._def.routerConfig);\n      return {\n        slug: k as keyof TRouter,\n        config,\n      };\n    });\n\n    return permissions;\n  };\n};\n","import {\n  generateUploadThingURL,\n  pollForFileData,\n  UploadThingError,\n} from \"@uploadthing/shared\";\nimport type { FileData } from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\n\nconst isValidResponse = (response: Response) => {\n  if (!response.ok) return false;\n  if (response.status >= 400) return false;\n  if (!response.headers.has(\"x-uploadthing-version\")) return false;\n\n  return true;\n};\n\nexport const conditionalDevServer = async (opts: {\n  fileKey: string;\n  apiKey: string;\n}) => {\n  if (process.env.NODE_ENV !== \"development\") return;\n\n  const fileData = await pollForFileData(\n    {\n      url: generateUploadThingURL(`/api/pollUpload/${opts.fileKey}`),\n      apiKey: opts.apiKey,\n      sdkVersion: UPLOADTHING_VERSION,\n    },\n    async (json: { fileData: FileData }) => {\n      const file = json.fileData;\n\n      let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;\n      if (!callbackUrl.startsWith(\"http\"))\n        callbackUrl = \"http://\" + callbackUrl;\n\n      console.log(\"[UT] SIMULATING FILE UPLOAD WEBHOOK CALLBACK\", callbackUrl);\n\n      const response = await fetch(callbackUrl, {\n        method: \"POST\",\n        body: JSON.stringify({\n          status: \"uploaded\",\n          metadata: JSON.parse(file.metadata ?? \"{}\") as FileData[\"metadata\"],\n          file: {\n            url: `https://utfs.io/f/${encodeURIComponent(opts.fileKey)}`,\n            key: opts.fileKey,\n            name: file.fileName,\n            size: file.fileSize,\n          },\n        }),\n        headers: {\n          \"uploadthing-hook\": \"callback\",\n        },\n      });\n      if (isValidResponse(response)) {\n        console.log(\n          \"[UT] Successfully simulated callback for file\",\n          opts.fileKey,\n        );\n      } else {\n        console.error(\n          \"[UT] Failed to simulate callback for file. Is your webhook configured correctly?\",\n          opts.fileKey,\n        );\n      }\n      return file;\n    },\n  );\n\n  if (fileData !== null) return fileData;\n\n  console.error(`[UT] Failed to simulate callback for file ${opts.fileKey}`);\n  throw new UploadThingError({\n    code: \"UPLOAD_FAILED\",\n    message: \"File took too long to upload\",\n  });\n};\n","import type { Json } from \"@uploadthing/shared\";\n\nimport type { MaybePromise } from \"./types\";\n\n// Don't want to use Zod cause it's an optional dependency\nexport type ParseFn<TType> = (input: unknown) => MaybePromise<TType>;\nexport type ParserZodEsque<TInput, TParsedInput extends Json> = {\n  _input: TInput;\n  _output: TParsedInput; // if using .transform etc\n  parse: ParseFn<TParsedInput>;\n};\n\n// In case we add support for more parsers later\nexport type JsonParser = ParserZodEsque<Json, Json>;\n\nexport function getParseFn<TParser extends JsonParser>(\n  parser: TParser,\n): ParseFn<TParser[\"_output\"]> {\n  if (typeof parser.parse === \"function\") {\n    return parser.parse;\n  }\n\n  throw new Error(\"Invalid parser\");\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nimport type {\n  FileRouterInputConfig,\n  Json,\n  UploadedFile,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport type { JsonParser } from \"./parser\";\n\n//\n// Utils\nexport const unsetMarker = \"unsetMarker\" as \"unsetMarker\" & {\n  __brand: \"unsetMarker\";\n};\nexport type UnsetMarker = typeof unsetMarker;\n\nexport type Simplify<TType> = { [TKey in keyof TType]: TType[TKey] } & {};\n\nexport type MaybePromise<TType> = TType | Promise<TType>;\n\n/**\n * Omits the key without removing a potential union\n * @internal\n */\nexport type DistributiveOmit<TObj, TKey extends keyof any> = TObj extends any\n  ? Omit<TObj, TKey>\n  : never;\n\n//\n// Package\ntype ResolverOptions<TParams extends AnyParams> = {\n  metadata: Simplify<\n    TParams[\"_metadata\"] extends UnsetMarker ? undefined : TParams[\"_metadata\"]\n  >;\n\n  file: UploadedFile;\n};\n\nexport type AnyRuntime = \"app\" | \"pages\" | \"web\" | \"express\" | \"fastify\" | \"h3\";\n\nexport type MiddlewareFnArgs<TRequest, TResponse, TEvent> = {\n  req: TRequest;\n  res: TResponse;\n  event: TEvent;\n};\nexport interface AnyParams {\n  _input: any;\n  _metadata: any; // imaginary field used to bind metadata return type to an Upload resolver\n  _middlewareArgs: MiddlewareFnArgs<any, any, any>;\n  _errorShape: any;\n  _errorFn: any; // used for onUploadError\n  _output: any;\n}\n\ntype MiddlewareFn<\n  TInput extends JSON | UnsetMarker,\n  TOutput extends Record<string, unknown>,\n  TArgs extends MiddlewareFnArgs<any, any, any>,\n> = (\n  opts: TArgs & (TInput extends UnsetMarker ? {} : { input: TInput }),\n) => MaybePromise<TOutput>;\n\ntype ResolverFn<\n  TOutput extends Record<string, unknown> | void,\n  TParams extends AnyParams,\n> = (opts: ResolverOptions<TParams>) => MaybePromise<TOutput>;\n\ntype UploadErrorFn = (input: {\n  error: UploadThingError;\n  fileKey: string;\n}) => void;\n\nexport type ErrorMessage<TError extends string> = TError;\n\nexport interface UploadBuilder<TParams extends AnyParams> {\n  input: <TParser extends JsonParser>(\n    parser: TParams[\"_input\"] extends UnsetMarker\n      ? TParser\n      : ErrorMessage<\"input is already set\">,\n  ) => UploadBuilder<{\n    _input: TParser[\"_output\"];\n    _metadata: TParams[\"_metadata\"];\n    _middlewareArgs: TParams[\"_middlewareArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: TParams[\"_errorFn\"];\n    _output: UnsetMarker;\n  }>;\n  middleware: <TOutput extends Record<string, unknown>>(\n    fn: TParams[\"_metadata\"] extends UnsetMarker\n      ? MiddlewareFn<TParams[\"_input\"], TOutput, TParams[\"_middlewareArgs\"]>\n      : ErrorMessage<\"middleware is already set\">,\n  ) => UploadBuilder<{\n    _input: TParams[\"_input\"];\n    _metadata: TOutput;\n    _middlewareArgs: TParams[\"_middlewareArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: TParams[\"_errorFn\"];\n    _output: UnsetMarker;\n  }>;\n  onUploadComplete: <TOutput extends Record<string, unknown> | void>(\n    fn: ResolverFn<TOutput, TParams>,\n  ) => Uploader<{\n    _input: TParams[\"_input\"];\n    _metadata: TParams[\"_metadata\"];\n    _middlewareArgs: TParams[\"_middlewareArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: TParams[\"_errorFn\"];\n    _output: TOutput;\n  }>;\n  onUploadError: (\n    fn: TParams[\"_errorFn\"] extends UnsetMarker\n      ? UploadErrorFn\n      : ErrorMessage<\"onUploadError is already set\">,\n  ) => UploadBuilder<{\n    _input: TParams[\"_input\"];\n    _metadata: TParams[\"_metadata\"];\n    _middlewareArgs: TParams[\"_middlewareArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: UploadErrorFn;\n    _output: UnsetMarker;\n  }>;\n}\n\nexport type UploadBuilderDef<TParams extends AnyParams> = {\n  routerConfig: FileRouterInputConfig;\n  inputParser: JsonParser;\n  middleware: MiddlewareFn<TParams[\"_input\"], {}, TParams[\"_middlewareArgs\"]>;\n  errorFormatter: (err: UploadThingError) => TParams[\"_errorShape\"];\n  onUploadError: UploadErrorFn;\n};\n\nexport interface Uploader<TParams extends AnyParams> {\n  _def: TParams & UploadBuilderDef<TParams>;\n  resolver: ResolverFn<TParams[\"_output\"], TParams>;\n}\n\nexport type FileRouter<TParams extends AnyParams = AnyParams> = Record<\n  string,\n  Uploader<TParams>\n>;\n\nexport type inferEndpointInput<TUploader extends Uploader<any>> =\n  TUploader[\"_def\"][\"_input\"] extends UnsetMarker\n    ? undefined\n    : TUploader[\"_def\"][\"_input\"];\n\nexport type inferEndpointOutput<TUploader extends Uploader<any>> =\n  TUploader[\"_def\"][\"_output\"] extends UnsetMarker\n    ? undefined\n    : TUploader[\"_def\"][\"_output\"];\n\nexport type inferErrorShape<TRouter extends FileRouter> =\n  TRouter[keyof TRouter][\"_def\"][\"_errorShape\"];\n\nexport const VALID_ACTION_TYPES = [\n  \"upload\",\n  \"failure\",\n  \"multipart-complete\",\n] as const;\nexport type ActionType = (typeof VALID_ACTION_TYPES)[number];\n\nexport type UTEvents = {\n  upload: {\n    files: { name: string; size: number }[];\n    input: Json;\n  };\n  failure: {\n    fileKey: string;\n    uploadId: string;\n    s3Error?: string;\n    fileName: string;\n  };\n  \"multipart-complete\": {\n    fileKey: string;\n    uploadId: string;\n    etags: {\n      tag: string;\n      partNumber: number;\n    }[];\n  };\n};\n","import type {\n  FileRouterInputConfig,\n  Json,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { defaultErrorFormatter } from \"./error-formatter\";\nimport type {\n  AnyParams,\n  MiddlewareFnArgs,\n  UnsetMarker,\n  UploadBuilder,\n  UploadBuilderDef,\n  Uploader,\n} from \"./types\";\n\nfunction internalCreateBuilder<\n  TMiddlewareArgs extends MiddlewareFnArgs<any, any, any>,\n  TErrorShape extends Json = { message: string },\n>(\n  initDef: Partial<UploadBuilderDef<any>> = {},\n): UploadBuilder<{\n  _input: UnsetMarker;\n  _metadata: UnsetMarker;\n  _middlewareArgs: TMiddlewareArgs;\n  _errorShape: TErrorShape;\n  _errorFn: UnsetMarker;\n  _output: UnsetMarker;\n}> {\n  const _def: UploadBuilderDef<AnyParams> = {\n    // Default router config\n    routerConfig: {\n      image: {\n        maxFileSize: \"4MB\",\n      },\n    },\n\n    inputParser: { parse: () => ({}), _input: {}, _output: {} },\n\n    middleware: () => ({}),\n    onUploadError: () => ({}),\n\n    errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,\n\n    // Overload with properties passed in\n    ...initDef,\n  };\n\n  return {\n    input(userParser) {\n      return internalCreateBuilder({\n        ..._def,\n        inputParser: userParser,\n      }) as UploadBuilder<any>;\n    },\n    middleware(userMiddleware) {\n      return internalCreateBuilder({\n        ..._def,\n        middleware: userMiddleware,\n      }) as UploadBuilder<any>;\n    },\n    onUploadComplete(userUploadComplete) {\n      return {\n        _def,\n        resolver: userUploadComplete,\n      } as Uploader<any>;\n    },\n    onUploadError(userOnUploadError) {\n      return internalCreateBuilder({\n        ..._def,\n        onUploadError: userOnUploadError,\n      }) as UploadBuilder<any>;\n    },\n  };\n}\n\ntype InOut<\n  TMiddlewareArgs extends MiddlewareFnArgs<any, any, any>,\n  TErrorShape extends Json = { message: string },\n> = (input: FileRouterInputConfig) => UploadBuilder<{\n  _input: UnsetMarker;\n  _metadata: UnsetMarker;\n  _middlewareArgs: TMiddlewareArgs;\n  _errorShape: TErrorShape;\n  _errorFn: UnsetMarker;\n  _output: UnsetMarker;\n}>;\n\nexport type CreateBuilderOptions<TErrorShape extends Json> = {\n  errorFormatter: (err: UploadThingError) => TErrorShape;\n};\n\nexport function createBuilder<\n  TMiddlewareArgs extends MiddlewareFnArgs<any, any, any>,\n  TErrorShape extends Json = { message: string },\n>(\n  opts?: CreateBuilderOptions<TErrorShape>,\n): InOut<TMiddlewareArgs, TErrorShape> {\n  return (input: FileRouterInputConfig) => {\n    return internalCreateBuilder<TMiddlewareArgs, TErrorShape>({\n      routerConfig: input,\n      ...opts,\n    });\n  };\n}\n"],"mappings":"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","names":["import_shared","import_shared","res","parseAndExpandInputConfig","EventEmitter"]}