import * as _uploadthing_shared from '@uploadthing/shared';
import { ExpandedRouteConfig, UploadThingError } from '@uploadthing/shared';
import { F as FileRouter, i as inferEndpointOutput, D as DistributiveOmit, a as inferEndpointInput } from './types-c4814a3e.js';
import { ReactNode, CSSProperties } from 'react';
import { JSX } from 'solid-js/jsx-runtime';

/**
 * Shared helpers for our premade components that's reusable by multiple frameworks
 */
declare const generatePermittedFileTypes: (config?: ExpandedRouteConfig) => {
    fileTypes: _uploadthing_shared.FileRouterInputKey[];
    multiple: boolean;
};
declare const capitalizeStart: (str: string) => string;
declare const INTERNAL_doFormatting: (config?: ExpandedRouteConfig) => string;
declare const allowedContentTextLabelGenerator: (config?: ExpandedRouteConfig) => string;
type AnyRuntime = "react" | "solid";
type MinCallbackArg = {
    __runtime: AnyRuntime;
};
type inferRuntime<T extends MinCallbackArg> = T["__runtime"] extends "react" ? "react" : "solid";
type ElementEsque<TRuntime extends AnyRuntime> = TRuntime extends "react" ? ReactNode : JSX.Element;
type CSSPropertiesEsque<TRuntime extends AnyRuntime> = TRuntime extends "react" ? CSSProperties : JSX.CSSProperties;
type StyleField<CallbackArg extends MinCallbackArg, TRuntime extends AnyRuntime = inferRuntime<CallbackArg>> = string | CSSPropertiesEsque<TRuntime> | ((arg: Omit<CallbackArg, "__runtime">) => string | CSSPropertiesEsque<TRuntime>);
type ContentField<CallbackArg extends MinCallbackArg, TRuntime extends AnyRuntime = inferRuntime<CallbackArg>> = ElementEsque<TRuntime> | ((arg: Omit<CallbackArg, "__runtime">) => ElementEsque<TRuntime>);
declare const styleFieldToClassName: <T extends MinCallbackArg>(styleField: StyleField<T, inferRuntime<T>> | undefined, args: T) => string;
declare const styleFieldToCssObject: <T extends MinCallbackArg>(styleField: StyleField<T, inferRuntime<T>> | undefined, args: T) => CSSPropertiesEsque<inferRuntime<T>>;
declare const contentFieldToContent: <T extends MinCallbackArg>(contentField: ContentField<T, inferRuntime<T>> | undefined, arg: T) => ElementEsque<inferRuntime<T>> | null | undefined;

type UploadFilesOptions<TRouter extends FileRouter, TEndpoint extends keyof TRouter> = {
    onUploadProgress?: ({ file, progress, }: {
        file: string;
        progress: number;
    }) => void;
    onUploadBegin?: ({ file }: {
        file: string;
    }) => void;
    files: File[];
    /**
     * URL to the UploadThing API endpoint
     * @example URL { http://localhost:3000/api/uploadthing }
     * @example URL { https://www.example.com/api/uploadthing }
     */
    url: URL;
} & (undefined extends inferEndpointInput<TRouter[TEndpoint]> ? {} : {
    input: inferEndpointInput<TRouter[TEndpoint]>;
});
declare const INTERNAL_DO_NOT_USE__fatalClientError: (e: Error) => UploadThingError<{
    message: string;
}>;
type UploadFileResponse<TServerOutput> = {
    name: string;
    size: number;
    key: string;
    url: string;
    serverData: TServerOutput;
};
declare const DANGEROUS__uploadFiles: <TRouter extends FileRouter, TEndpoint extends keyof TRouter>(endpoint: TEndpoint, opts: UploadFilesOptions<TRouter, TEndpoint>) => Promise<{
    name: string;
    size: number;
    key: string;
    serverData: Awaited<inferEndpointOutput<TRouter[TEndpoint]>>;
    url: string;
}[]>;
declare const genUploader: <TRouter extends FileRouter>(initOpts: {
    /**
     * URL to the UploadThing API endpoint
     * @example URL { /api/uploadthing }
     * @example URL { https://www.example.com/api/uploadthing }
     *
     * If relative, host will be inferred from either the `VERCEL_URL` environment variable or `window.location.origin`
     *
     * @default (VERCEL_URL ?? window.location.origin) + "/api/uploadthing"
     */
    url?: string | URL;
}) => <TEndpoint extends keyof TRouter>(endpoint: TEndpoint, opts: DistributiveOmit<UploadFilesOptions<TRouter, TEndpoint>, "url">) => Promise<{
    name: string;
    size: number;
    key: string;
    serverData: Awaited<inferEndpointOutput<TRouter[TEndpoint]>>;
    url: string;
}[]>;
declare const classNames: (...classes: (string | boolean)[]) => string;
declare const generateMimeTypes: (fileTypes: string[]) => string[] | undefined;
declare const generateClientDropzoneAccept: (fileTypes: string[]) => {
    [k: string]: never[];
} | undefined;
declare function getFullApiUrl(maybeUrl?: string): URL;

export { ContentField, DANGEROUS__uploadFiles, INTERNAL_DO_NOT_USE__fatalClientError, INTERNAL_doFormatting, StyleField, UploadFileResponse, allowedContentTextLabelGenerator, capitalizeStart, classNames, contentFieldToContent, genUploader, generateClientDropzoneAccept, generateMimeTypes, generatePermittedFileTypes, getFullApiUrl, styleFieldToClassName, styleFieldToCssObject };
