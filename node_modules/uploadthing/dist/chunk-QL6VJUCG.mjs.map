{"version":3,"sources":["../src/server.ts","../src/sdk/index.ts","../src/sdk/utils.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\n\nimport { getStatusCodeFromError, UploadThingError } from \"@uploadthing/shared\";\nimport type { Json } from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"./constants\";\nimport { formatError } from \"./internal/error-formatter\";\nimport type { RouterWithConfig } from \"./internal/handler\";\nimport {\n  buildPermissionsInfoHandler,\n  buildRequestHandler,\n} from \"./internal/handler\";\nimport { incompatibleNodeGuard } from \"./internal/incompat-node-guard\";\nimport type { FileRouter } from \"./internal/types\";\nimport type { CreateBuilderOptions } from \"./internal/upload-builder\";\nimport { createBuilder } from \"./internal/upload-builder\";\n\nexport * from \"./internal/types\";\nexport { UTApi } from \"./sdk\";\n\nexport const createUploadthing = <TErrorShape extends Json>(\n  opts?: CreateBuilderOptions<TErrorShape>,\n) =>\n  createBuilder<\n    { req: Request; res: undefined; event: undefined },\n    TErrorShape\n  >(opts);\n\nexport const createServerHandler = <TRouter extends FileRouter>(\n  opts: RouterWithConfig<TRouter>,\n) => {\n  incompatibleNodeGuard();\n  const ee = new EventEmitter();\n  const requestHandler = buildRequestHandler<TRouter>(opts, ee);\n\n  const POST = async (request: Request | { request: Request }) => {\n    const req = request instanceof Request ? request : request.request;\n    const response = await requestHandler({ req });\n\n    if (response instanceof UploadThingError) {\n      return new Response(JSON.stringify(formatError(response, opts.router)), {\n        status: getStatusCodeFromError(response),\n        headers: {\n          \"x-uploadthing-version\": UPLOADTHING_VERSION,\n        },\n      });\n    }\n    if (response.status !== 200) {\n      // We messed up - this should never happen\n      return new Response(\"An unknown error occured\", {\n        status: 500,\n        headers: {\n          \"x-uploadthing-version\": UPLOADTHING_VERSION,\n        },\n      });\n    }\n\n    return new Response(JSON.stringify(response.body), {\n      status: response.status,\n      headers: {\n        \"x-uploadthing-version\": UPLOADTHING_VERSION,\n      },\n    });\n  };\n\n  const getBuildPerms = buildPermissionsInfoHandler<TRouter>(opts);\n\n  const GET = async (request: Request | { request: Request }) => {\n    const req = request instanceof Request ? request : request.request;\n\n    const clientPollingKey = req.headers.get(\"x-uploadthing-polling-key\");\n    if (clientPollingKey) {\n      const eventData = await new Promise((resolve) => {\n        ee.addListener(\"callbackDone\", resolve);\n      });\n      ee.removeAllListeners(\"callbackDone\");\n\n      return new Response(JSON.stringify(eventData), {\n        status: 200,\n        headers: {\n          \"x-uploadthing-version\": UPLOADTHING_VERSION,\n        },\n      });\n    }\n\n    return new Response(JSON.stringify(getBuildPerms()), {\n      status: 200,\n      headers: {\n        \"x-uploadthing-version\": UPLOADTHING_VERSION,\n      },\n    });\n  };\n\n  return { GET, POST };\n};\n\nexport const extractRouterConfig = (router: FileRouter) =>\n  buildPermissionsInfoHandler({ router })();\n","import type {\n  ContentDisposition,\n  FetchEsque,\n  Json,\n  MaybeUrl,\n} from \"@uploadthing/shared\";\nimport { generateUploadThingURL, UploadThingError } from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\nimport { incompatibleNodeGuard } from \"../internal/incompat-node-guard\";\nimport type { FileEsque, UploadFileResponse } from \"./utils\";\nimport {\n  getApiKeyOrThrow,\n  guardServerOnly,\n  uploadFilesInternal,\n} from \"./utils\";\n\nexport interface UTApiOptions {\n  /**\n   * Provide a custom fetch function.\n   * @default globalThis.fetch\n   */\n  fetch?: FetchEsque;\n  /**\n   * Provide a custom UploadThing API key.\n   * @default process.env.UPLOADTHING_SECRET\n   */\n  apiKey?: string;\n}\n\nexport class UTApi {\n  private fetch: FetchEsque;\n  private apiKey: string | undefined;\n  private defaultHeaders: Record<string, string>;\n\n  constructor(opts?: UTApiOptions) {\n    this.fetch = opts?.fetch ?? globalThis.fetch;\n    this.apiKey = opts?.apiKey ?? process.env.UPLOADTHING_SECRET;\n    this.defaultHeaders = {\n      \"Content-Type\": \"application/json\",\n      \"x-uploadthing-api-key\": this.apiKey!,\n      \"x-uploadthing-version\": UPLOADTHING_VERSION,\n    };\n\n    // Assert some stuff\n    guardServerOnly();\n    getApiKeyOrThrow(this.apiKey);\n    incompatibleNodeGuard();\n  }\n\n  private async requestUploadThing<T extends Record<string, unknown>>(\n    pathname: `/${string}`,\n    body: Record<string, unknown>,\n    fallbackErrorMessage: string,\n  ) {\n    const res = await this.fetch(generateUploadThingURL(pathname), {\n      method: \"POST\",\n      cache: \"no-store\",\n      headers: this.defaultHeaders,\n      body: JSON.stringify(body),\n    });\n\n    const json = await res.json<T | { error: string }>();\n    if (!res.ok || \"error\" in json) {\n      console.error(\"[UT] Error:\", json);\n      throw new UploadThingError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message:\n          \"error\" in json && typeof json.error === \"string\"\n            ? json.error\n            : fallbackErrorMessage,\n      });\n    }\n\n    return json;\n  }\n\n  /**\n   * @param {FileEsque | FileEsque[]} files The file(s) to upload\n   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)\n   *\n   * @example\n   * await uploadFiles(new File([\"foo\"], \"foo.txt\"));\n   *\n   * @example\n   * await uploadFiles([\n   *   new File([\"foo\"], \"foo.txt\"),\n   *   new File([\"bar\"], \"bar.txt\"),\n   * ]);\n   */\n  async uploadFiles<T extends FileEsque | FileEsque[]>(\n    files: T,\n    opts?: {\n      metadata?: Json;\n      contentDisposition?: ContentDisposition;\n    },\n  ) {\n    guardServerOnly();\n\n    const filesToUpload: FileEsque[] = Array.isArray(files) ? files : [files];\n\n    const uploads = await uploadFilesInternal(\n      {\n        files: filesToUpload,\n        metadata: opts?.metadata ?? {},\n        contentDisposition: opts?.contentDisposition ?? \"inline\",\n      },\n      {\n        fetch: this.fetch,\n        utRequestHeaders: this.defaultHeaders,\n      },\n    );\n\n    const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];\n\n    return uploadFileResponse as T extends FileEsque[]\n      ? UploadFileResponse[]\n      : UploadFileResponse;\n  }\n\n  /**\n   * @param {string} url The URL of the file to upload\n   * @param {Json} metadata JSON-parseable metadata to attach to the uploaded file(s)\n   *\n   * @example\n   * await uploadFileFromUrl(\"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   *\n   * @example\n   * await uploadFileFromUrl([\n   *   \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\n   *   \"https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"\n   * ])\n   */\n  async uploadFilesFromUrl<T extends MaybeUrl | MaybeUrl[]>(\n    urls: T,\n    opts?: {\n      metadata: Json;\n      contentDisposition: ContentDisposition;\n    },\n  ) {\n    guardServerOnly();\n\n    const fileUrls: MaybeUrl[] = Array.isArray(urls) ? urls : [urls];\n\n    const formData = new FormData();\n    formData.append(\"metadata\", JSON.stringify(opts?.metadata ?? {}));\n\n    const filesToUpload = await Promise.all(\n      fileUrls.map(async (url) => {\n        if (typeof url === \"string\") url = new URL(url);\n        const filename = url.pathname.split(\"/\").pop() ?? \"unknown-filename\";\n\n        // Download the file on the user's server to avoid egress charges\n        const fileResponse = await fetch(url);\n        if (!fileResponse.ok) {\n          throw new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Failed to download requested file.\",\n            cause: fileResponse,\n          });\n        }\n        const blob = await fileResponse.blob();\n        return Object.assign(blob, { name: filename });\n      }),\n    );\n\n    const uploads = await uploadFilesInternal(\n      {\n        files: filesToUpload,\n        metadata: opts?.metadata ?? {},\n        contentDisposition: opts?.contentDisposition ?? \"inline\",\n      },\n      {\n        fetch: this.fetch,\n        utRequestHeaders: this.defaultHeaders,\n      },\n    );\n\n    const uploadFileResponse = Array.isArray(urls) ? uploads : uploads[0];\n\n    return uploadFileResponse as T extends MaybeUrl[]\n      ? UploadFileResponse[]\n      : UploadFileResponse;\n  }\n\n  /**\n   * Request to delete files from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * await deleteFiles(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   *\n   * @example\n   * await deleteFiles([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   */\n  async deleteFiles(fileKeys: string[] | string) {\n    guardServerOnly();\n\n    if (!Array.isArray(fileKeys)) fileKeys = [fileKeys];\n\n    return this.requestUploadThing<{ success: boolean }>(\n      \"/api/deleteFile\",\n      { fileKeys },\n      \"An unknown error occured while deleting files.\",\n    );\n  }\n\n  /**\n   * Request file URLs from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * const data = await getFileUrls(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   * console.log(data); // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\"}]\n   *\n   * @example\n   * const data = await getFileUrls([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   * console.log(data) // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\" },{key: \"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\", url: \"https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"}]\n   */\n  async getFileUrls(fileKeys: string[] | string) {\n    guardServerOnly();\n\n    if (!Array.isArray(fileKeys)) fileKeys = [fileKeys];\n\n    const json = await this.requestUploadThing<{\n      data: { key: string; url: string }[];\n    }>(\n      \"/api/getFileUrl\",\n      { fileKeys },\n      \"An unknown error occured while retrieving file URLs.\",\n    );\n\n    return json.data;\n  }\n\n  /**\n   * Request file list from UploadThing storage.\n   *\n   * @example\n   * const data = await listFiles();\n   * console.log(data); // { key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", id: \"2e0fdb64-9957-4262-8e45-f372ba903ac8\" }\n   */\n  async listFiles() {\n    guardServerOnly();\n\n    // TODO: Implement filtering and pagination\n    const json = await this.requestUploadThing<{\n      files: {\n        key: string;\n        id: string;\n        status: \"Deletion Pending\" | \"Failed\" | \"Uploaded\" | \"Uploading\";\n      }[];\n    }>(\"/api/listFiles\", {}, \"An unknown error occured while listing files.\");\n\n    return json.files;\n  }\n\n  async renameFile(\n    updates:\n      | {\n          fileKey: string;\n          newName: string;\n        }\n      | {\n          fileKey: string;\n          newName: string;\n        }[],\n  ) {\n    guardServerOnly();\n\n    if (!Array.isArray(updates)) updates = [updates];\n\n    return this.requestUploadThing<{ success: true }>(\n      \"/api/renameFile\",\n      { updates },\n      \"An unknown error occured while renaming files.\",\n    );\n  }\n\n  async getUsageInfo() {\n    guardServerOnly();\n\n    return this.requestUploadThing<{\n      totalBytes: number;\n      totalReadable: string;\n      appTotalBytes: number;\n      appTotalReadable: string;\n      filesUploaded: number;\n      limitBytes: number;\n      limitReadable: string;\n    }>(\n      \"/api/getUsageInfo\",\n      {},\n      \"An unknown error occured while getting usage info.\",\n    );\n  }\n}\n","import type { File as UndiciFile } from \"undici\";\n\nimport type { ContentDisposition, FetchEsque, Json } from \"@uploadthing/shared\";\nimport {\n  generateUploadThingURL,\n  pollForFileData,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\nimport { uploadPart } from \"../internal/multi-part\";\nimport type { UTEvents } from \"../server\";\n\nexport function guardServerOnly() {\n  if (typeof window !== \"undefined\") {\n    throw new UploadThingError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"The `utapi` can only be used on the server.\",\n    });\n  }\n}\n\nexport function getApiKeyOrThrow(apiKey?: string) {\n  if (apiKey) return apiKey;\n  if (process.env.UPLOADTHING_SECRET) return process.env.UPLOADTHING_SECRET;\n\n  throw new UploadThingError({\n    code: \"MISSING_ENV\",\n    message: \"Missing `UPLOADTHING_SECRET` env variable.\",\n  });\n}\n\nexport type FileEsque = (Blob & { name: string }) | UndiciFile;\n\nexport type UploadData = {\n  key: string;\n  url: string;\n  name: string;\n  size: number;\n};\n\nexport type UploadError = {\n  code: string;\n  message: string;\n  data: any;\n};\n\nexport type UploadFileResponse =\n  | { data: UploadData; error: null }\n  | { data: null; error: UploadError };\n\nexport const uploadFilesInternal = async (\n  data: {\n    files: FileEsque[];\n    metadata: Json;\n    contentDisposition: ContentDisposition;\n  },\n  opts: {\n    fetch: FetchEsque;\n    utRequestHeaders: Record<string, string>;\n  },\n) => {\n  // Request presigned URLs for each file\n  const fileData = data.files.map((file) => ({\n    name: file.name ?? \"unnamed-blob\",\n    type: file.type,\n    size: file.size,\n  }));\n  const res = await opts.fetch(generateUploadThingURL(\"/api/uploadFiles\"), {\n    method: \"POST\",\n    headers: opts.utRequestHeaders,\n    cache: \"no-store\",\n    body: JSON.stringify({\n      files: fileData,\n      metadata: data.metadata,\n      contentDisposition: data.contentDisposition,\n    }),\n  });\n\n  if (!res.ok) {\n    const error = await UploadThingError.fromResponse(res);\n    throw error;\n  }\n\n  const clonedRes = res.clone(); // so that `UploadThingError.fromResponse()` can consume the body again\n  const json = await res.json<\n    | {\n        data: {\n          presignedUrls: string[];\n          key: string;\n          fileUrl: string;\n          fileType: string;\n          uploadId: string;\n          chunkSize: number;\n          chunkCount: number;\n        }[];\n      }\n    | { error: string }\n  >();\n\n  if (\"error\" in json) {\n    const error = await UploadThingError.fromResponse(clonedRes);\n    throw error;\n  }\n\n  // Upload each file to S3 in chunks using multi-part uploads\n  const uploads = await Promise.allSettled(\n    data.files.map(async (file, i) => {\n      const { presignedUrls, key, fileUrl, uploadId, chunkSize } = json.data[i];\n\n      if (!presignedUrls || !Array.isArray(presignedUrls)) {\n        throw new UploadThingError({\n          code: \"URL_GENERATION_FAILED\",\n          message: \"Failed to generate presigned URL\",\n          cause: JSON.stringify(json.data[i]),\n        });\n      }\n\n      const etags = await Promise.all(\n        presignedUrls.map(async (url, index) => {\n          const offset = chunkSize * index;\n          const end = Math.min(offset + chunkSize, file.size);\n          const chunk = file.slice(offset, end);\n\n          const etag = await uploadPart({\n            fetch: opts.fetch,\n            url,\n            chunk: chunk as Blob,\n            contentDisposition: data.contentDisposition,\n            contentType: file.type,\n            fileName: file.name,\n            maxRetries: 10,\n            key,\n            utRequestHeaders: opts.utRequestHeaders,\n          });\n\n          return { tag: etag, partNumber: index + 1 };\n        }),\n      );\n\n      // Complete multipart upload\n      await opts.fetch(generateUploadThingURL(\"/api/completeMultipart\"), {\n        method: \"POST\",\n        body: JSON.stringify({\n          fileKey: key,\n          uploadId,\n          etags,\n        } satisfies UTEvents[\"multipart-complete\"]),\n        headers: opts.utRequestHeaders,\n      });\n\n      // Poll for file to be available\n      await pollForFileData({\n        url: generateUploadThingURL(`/api/pollUpload/${key}`),\n        apiKey: opts.utRequestHeaders[\"x-uploadthing-api-key\"],\n        sdkVersion: UPLOADTHING_VERSION,\n      });\n\n      return {\n        key,\n        url: fileUrl,\n        name: file.name,\n        size: file.size,\n      };\n    }),\n  );\n\n  return uploads.map((upload) => {\n    if (upload.status === \"fulfilled\") {\n      const data = upload.value satisfies UploadData;\n      return { data, error: null };\n    }\n    // We only throw UploadThingErrors, so this is safe\n    const reason = upload.reason as UploadThingError;\n    const error = UploadThingError.toObject(reason) satisfies UploadError;\n    return { data: null, error };\n  });\n};\n"],"mappings":"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","names":["UploadThingError","generateUploadThingURL","UploadThingError","data","generateUploadThingURL","UploadThingError","UploadThingError"]}